#!/usr/bin/env ruby
CinemaSlidesVersion = "v0.2010.10.05"
Author = "Wolfgang Woehl"
#
# Cinemaslides is a glue tool to create slideshows for digital cinema (DCPs)
#
# Run "cinemaslides -h" to see options
# Run "cinemaslides --examples" to see a couple of example invocations
#
# Export CINEMASLIDESDIR to point to the desired location for temporary files, asset depot etc.
#   (or use the default location HOME/cinemaslidesdir)
#
# Requires:
#   ruby, gem, bash
#   ImageMagick, MPlayer, SoX
#   OpenJPEG (http://code.google.com/p/openjpeg/downloads/list) or Kakadu (see the note on Kakadu's terms of use below)
#   asdcplib (http://www.cinecert.com/asdcplib/)
#   highline (gem install highline)
#   nokogiri (gem install nokogiri, requires ruby-dev, libxml2-dev)
#
requirements = [ 'convert', 'identify', 'montage', 'display', 'mplayer', 'sox', 'soxi', 'image_to_j2k', 'kdu_compress', 'asdcp-test', 'kmuuidgen' ]
#
###
#   Kakadu (http://www.kakadusoftware.com/index.php) is a proprietary JPEG 2000 implementation, written by Dr. Taubman
#   Kakadu Copyright is owned by NewSouth Innovations Proprietary Ltd, commercial arm of the University of New South Wales, Sydney, Australia
#   Its feature set and performance are quite impressive. It is significantly faster than OpenJPEG's implementation.
#   Kakadu is available for demonstration purposes (Windows, Mac, Linux).
#   Please see "Downloadable Executables Copyright and Disclaimer" at 
#   http://www.kakadusoftware.com/index.php?option=com_content&task=view&id=26&Itemid=22
#   and make sure you respect these terms of use. Thank you.
###
#
# Ruby geeks: If you value your sanity don't read beyond this line. I'm working on it ...

require 'fileutils'
require 'ftools' # File.copy. not needed (and not working) in ruby 1.9
require 'optparse'
require 'ostruct'
require 'digest/md5'
require 'base64'
require 'pp'
begin
  require 'rubygems'
rescue LoadError
end
require 'nokogiri'
require 'highline/import'


# FIXME catch missing parameters, false options, typos etc.
class Optparser
  def self.parse(args)
    
    # defaults
    options = OpenStruct.new
    options.output_type = 'preview'
    options.output_type_choices = [ 'preview', 'fullpreview', 'dcp' ]
    options.size = '2k'
    options.size_choices = [ '2k', '4k' ]
    options.aspect = 'flat'
    options.aspect_choices = [ 'flat', 'scope', 'hd', Regexp.new('\d+(\.\d+)?x\d+(\.\d+)?') ] # custom aspect ratios: match '<numeric>x<numeric>'
    options.aspect_malformed = FALSE
    options.resize = TRUE # option to _not_ resize images (useful for images which are close to target dimensions and would suffer from scaling/-resize)
    options.fps = 24.0
    options.fps_dcp_choices = [ 24.0, 48.0 ]
    options.fps_asdcp_choices = [ 23.976, 24.0, 25.0, 30.0, 48.0, 50.0, 60.0 ] # 24000/1001 not DCI compliant but shows up in asdcplib. Why?
    options.encoder = 'openjpeg'
    options.encoder_choices = [ 'openjpeg', 'kakadu' ]
    options.output_format = 'jpg'
    options.black = 0.0
    options.black_leader = NIL
    options.black_tail = NIL
    options.audio_samplerate = 48000
    options.audio_samplerate_choices = [ '48000', '48k', '96000', '96k' ]
    options.audio_bps = 24
    options.audio_bps_choices = [ '16', '24' ]
    options.dcp_title = 'Cinemaslides test'
    options.dcp_issuer = ENV[ 'USER' ] + '@' + `hostname`.chomp
    options.dcp_annotation = 'Cinemaslides test ' + DateTime.now.to_s
    options.dcp_kind = 'test'
    options.dcp_kind_choices = [ 'feature', 'trailer', 'test', 'teaser', 'rating', 'advertisement', 'short', 'transitional', 'psa', 'policy' ]
    options.dcp_wrap_stereoscopic = FALSE
    options.dcp_user_output_path = nil
    options.montage = FALSE
    options.keep = FALSE
    options.dont_check = FALSE
    options.dont_drop = FALSE
    options.verbosity = 'info'
    options.verbosity_choices = [ 'quiet', 'info', 'debug' ]
    options.transition_and_timing = Array.new
    options.transition_and_timing_choices = [ 'cut', 'fade', 'crossfade' ]
    options.transition_and_timing << 'cut'
    options.transition_and_timing << 5 # duration
    options.mplayer_gamma = 1.2


    opts = OptionParser.new do |opts|
      opts.banner = <<BANNER
cinemaslides #{ CinemaSlidesVersion } #{ ENV[ 'CINEMASLIDESDIR' ].nil? ? "\nExport CINEMASLIDESDIR to point to desired work directory needed for temporary files, thumbnails, asset depot, DCPs (Default: HOME/cinemaslidesdir)" : "\nCINEMASLIDESDIR is set (#{ ENV[ 'CINEMASLIDESDIR' ] })" }

Usage: #{ File.basename( $0 ) } [-t, --type <type>] [-k, --size <DCP resolution>] [-a, --aspect <aspect name or widthxheight>] [--dont-resize] [--fps <fps>] [-x --transition-and-timing <type,a,b[,c]>] [-j, --encoder <encoder>] [-f, --output-format <image suffix>] [-b, --black <seconds>] [--bl, --black-leader <seconds>] [--bt, --black-tail <seconds>] [-s, --samplerate <audio samplerate>] [--bps <bits per audio sample>] [--title <DCP title>] [--issuer <DCP issuer>] [--annotation <DCP annotation>] [--kind <DCP kind>] [--wrap-stereoscopic] [-o, --dcp_out <path>] [-m, --montagepreview] [--mg, --mplayer-gamma <gamma>] [--keep] [--dont-check] [--dont-drop] [-v, --verbosity <level>] [--examples] [-h, --help] image [more images ...] audiofile [more audiofiles ...]

BANNER

      opts.on( '-t', '--type type', String, "Use 'preview' (half size) or 'fullpreview' (full size) or 'dcp' (Default: preview)" ) do |p|
        if options.output_type_choices.include?( p.downcase )
          options.output_type = p.downcase
        else
          options.output_type = 'catch:' + p
        end
      end
      opts.on( '-k', '--size resolution', String, "Use '2k' or '4k' (Default: 2k)" ) do |p|
        if options.size_choices.include?( p.downcase )
          options.size = p.downcase
        else
          options.size = 'catch:' + p.downcase
        end
      end
      opts.on( '-a', '--aspect ratio', String, "For standard aspect ratios use 'flat', 'scope' or 'hd' (Default: flat). You can also experiment with custom aspect ratios by saying '<width>x<height>'. The numbers given will be scaled to fit into the target container (Default size or specified with '--size')." ) do |p|
        if options.aspect_choices.include?( p.downcase )
          options.aspect = p.downcase
        elsif p.match( options.aspect_choices.last )
          options.aspect = 'Custom aspect ratio:' + p
        else
          options.aspect_malformed = TRUE
        end
      end
      opts.on( '--dont-resize', 'Do not resize images (Useful for images close to target dimensions)' ) do
        options.resize = FALSE
      end
      opts.on( '--fps fps', 'Framerate (Default: 24)', Float ) do |p| # 23.976
        options.fps = p.to_f
      end
      opts.on( '-x', '--transition-and-timing transition,seconds[,seconds[,seconds]]', Array, "Use this option to specify the transition type ('cut', 'fade' or 'crossfade') and timing parameters (Default: '-x cut,5'). Separate parameters with comma (no spaces)" ) do |p|
        if options.transition_and_timing_choices.include?( p.first.downcase )
          options.transition_and_timing = p
        else
          options.transition_and_timing[ 0 ] = 'malformed'
        end
      end
      opts.on( '-j', '--encoder codec', String, "Use 'openjpeg' or 'kakadu' for JPEG 2000 encoding (Default: openjpeg)" ) do |p|
        options.encoder = p.downcase
      end
      opts.on( '-f', '--output-format suffix', String, "Use 'jpg' or any other image related suffix (Default: jpg for previews, tiff for DCPs)" ) do |p|
        options.output_format = p
      end
      opts.on( '-b', '--black seconds', Float, 'Length of black leader and tail (Default: 0)' ) do |p|
        options.black = p
      end
      opts.on( '--bl', '--black-leader seconds', Float, 'Length of black leader (Default: 0)' ) do |p|
        options.black_leader = p
      end
      opts.on( '--bt', '--black-tail seconds', Float, 'Length of black tail (Default: 0)' ) do |p|
        options.black_tail = p
      end
      opts.on( '-r', '--samplerate rate', String, "Audio samplerate. Use '48000', '48k', '96000' or '96k' (Default: 48k)" ) do |p|
        if options.audio_samplerate_choices.include?( p.downcase )
          case p.downcase
          when '48000', '48k'
            options.audio_samplerate = 48000
          when '96000', '96k'
            options.audio_samplerate = 96000
          end
        end
      end
      opts.on( '--bps bps', Integer, "Bits per audio sample. Use '16' or '24' (Default: 24)" ) do |p|
        if options.audio_bps_choices.include?( p )
          options.audio_bps = p
        end
      end
      opts.on( '--title title', 'DCP title tag', String ) do |p|
        options.dcp_title = p
      end
      opts.on( '--issuer issuer', 'DCP issuer tag', String ) do |p|
        options.dcp_issuer = p
      end
      opts.on( '--annotation annotation', 'DCP annotation tag', String ) do |p|
        options.dcp_annotation = p
      end
      opts.on( '--kind kind', "DCP content kind. Use 'feature', 'trailer, 'test', 'teaser', 'rating', 'advertisement', 'short', 'transitional', 'psa' or 'policy' (Default: test)" ) do |p|
        if options.dcp_kind_choices.include?( p.downcase )
          options.dcp_kind = p.downcase
        end
      end
      opts.on( '--wrap-stereoscopic', 'Wrap images as stereoscopic essence (Useful when a monoscopic slideshow needs to run on a 3D projector preset)' ) do
        options.dcp_wrap_stereoscopic = TRUE
      end
      opts.on( '-o', '--dcp-out path', String, 'DCP location and folder name (Full path. Default: Write to working directory)' ) do |p|
        options.dcp_user_output_path = p
      end
      opts.on( '-m', '--montagepreview', 'Display a montage of the images before processing' ) do
        options.montage = TRUE
      end
      opts.on( '--mg', '--mplayer-gamma gamma', Float, 'Tweak mplayer gamma (Used for previews. Range 0.1 - 10. Default: 1.2)' ) do |p|
        options.mplayer_gamma = p if ( 0.1 <= p and p <= 10 )
      end
      opts.on( '--keep', 'Do not remove preview/temporary files' ) do
        options.keep = TRUE
      end
      opts.on( '--dont-check', 'Do not check files' ) do
        options.dont_check = TRUE
      end
      opts.on( '--dont-drop', 'Do not drop and ignore unreadable files or files ImageMagick cannot decode but nag and exit instead' ) do
        options.dont_drop = TRUE
      end
      opts.on( '-v', '--verbosity level', String, "Use 'quiet', 'info' or 'debug' (Default: info)" ) do |p|
        if options.verbosity_choices.include?( p )
          options.verbosity = p
        else
          options.verbosity = "info"
        end
      end

      opts.on( '--examples', 'Some examples and explanations' ) do
        app = File.basename( $0 )
        examples = <<EXAMPLES
cinemaslides #{ CinemaSlidesVersion }

Specify options in any order. Order of image/audio files matters. Audio is optional.
Audio timing is handled in a first-come, first-served manner -- independently from image timings

  Preview slideshow with audio (Half sized preview. Cut transition. Default duration: 5 seconds each):
$ #{ app } image1.jpg audio.wav image2.tiff

  Preview slideshow with audio (Full sized preview. Transition: crossfades for 1 second, 20 seconds at full level each):
$ #{ app } --type fullpreview -x crossfade,1,20 image1.tiff image2.ppm audio1.wav audio2.wav

  Create slideshow DCP, use all image files in directory 'slides' (Resolution: 2K. 5 seconds black leader):
$ #{ app } --type dcp --size 2k --black-leader 5 slides/*

  Create slideshow DCP (Preview thumbnails. Aspect ratio: scope):
$ #{ app } audio.wav *.tiff --montagepreview --aspect scope -t dcp --title 'Slideshow Test' --issuer 'Facility'

  Transition: fade in for 0.5 seconds, hold for 10, fade out for 4
$ #{ app } -x fade,0.5,10,4 ...

  Carousel goes berserk
$ #{ app } -t dcp --title "Motion sequence" --fps 24 -x fade,0,0.0416666666666667,0 motion_sequence/*

  Write DCP to custom location
$ #{ app } --dcp-out /media/usb-disk/slideshow --type dcp image.tiff audio.wav --title "First composition"

  Write another composition to the same custom location (PKL and ASSETMAP will be extended)
$ #{ app } -o /media/usb-disk/slideshow -t dcp image2.tiff image3.tiff song.wav --title "Another composition"

  Some kind of finer-grained timing control:
$ #{ app } -x cut,3    title title title 1st_slide 2nd_slide disclaimer disclaimer

  Slideshow of your truetype fonts:
$ #{ app } -x crossfade,2,2 `find /usr/share/fonts/truetype/ -name '*ttf' -type f`

  Custom aspect ratios (Work fine on a Solo G3, what about other servers?):
$ #{ app } --aspect 1.33x1 | --aspect 3072x2304 | --aspect 3x1 [...]
EXAMPLES
        puts examples
        exit
      end
      opts.on_tail( '-h', '--help', 'Display this screen' ) do
        puts opts
        exit
      end

    end
    opts.parse!(args)
    options
  end # parse
end # class


# reconstruct original commandline for readme file
commandline = File.basename( $0 )
ARGV.each do |arg|
  if arg =~ /.+\s.+/
    commandline += ' ' + '"' + arg + '"'
  else
    commandline += ' ' + arg
  end
end


options = Optparser.parse(ARGV)


class Logger
  attr_accessor :prefix
  def initialize( prefix, verbosity )
    @verbosity = verbosity
    @critical = TRUE
    case @verbosity
    when "quiet"
      @info = FALSE
      @warn = FALSE
      @debug = FALSE
    when "info"
      @info = TRUE
      @warn = TRUE
      @debug = FALSE
    when "debug"
      @info = TRUE
      @warn = TRUE
      @debug = TRUE
    end
    @prefix = prefix
    @color = Hash.new
    # these work ok on a black background:
    @color[:info] = ''
    @color[:debug] = '32'
    @color[:warn] = '33'
    @color[:critical] = '1'
  end
  def info( text )
    to_console( @color[:info], text ) if @info == TRUE
  end
  def warn( text )
    to_console( @color[:warn], text ) if @warn == TRUE
  end
  def debug( text )
    to_console( @color[:debug], text ) if @debug == TRUE
  end
  def critical( text )
    to_console( @color[:critical], text ) if @critical == TRUE
  end
  def cr( text )
    carriage_return( @color[:info], text ) unless @verbosity == "quiet"
  end
  def carriage_return( color, text )
    printf "\033[#{ color }m#{ @prefix } #{ text }\033[0m#{ ' ' * 24 }\r"; STDOUT.flush
  end
  def to_console( color, text )
    printf "\033[#{ color }m#{ @prefix } #{ text }\033[0m#{ ' ' * 24 }\n"
  end
end
@logger = Logger.new( '*', options.verbosity ) # prefix messages with '*'


def check_requirements( requirements )
  available_tools = Array.new
  missing_tools = Array.new
  requirements.each do |tool|
    exitstatus = system "which #{ tool } > /dev/null 2>&1"
    case exitstatus
    when TRUE
      available_tools << tool
    when FALSE
      missing_tools << tool
    end
  end
  return available_tools, missing_tools
end


def hours_minutes_seconds_verbose( seconds )
  t = seconds
  hrs = ( ( t / 3600 ) ).to_i
  min = ( ( t / 60 ) % 60 ).to_i
  sec = t % 60
  return [
    hrs > 0 ? hrs.to_s + " hour#{ 's' * ( hrs > 1 ? 1 : 0 ) }" : nil ,
    min > 0 ? min.to_s + " minute#{ 's' * ( min > 1 ? 1 : 0 ) }" : nil ,
    sec == 1 ? sec.to_i.to_s + ' second' : sec != 0 ? sec.to_s + ' seconds' : nil ,
    t > 60 ? "(#{ t } seconds)" : nil
  ].compact.join( ' ' )
end


def hms_from_seconds( seconds )
  hours = ( seconds / 3600.0 ).to_i
  minutes = ( ( seconds / 60.0 ) % 60 ).to_i
  secs = seconds % 60
  return [ hours, minutes, secs ].join( ':' )
end
def seconds_from_hms( timestring ) # hh:mm:ss.fraction
  a = timestring.split( ':' )
  hours = a[0].to_i
  minutes = a[1].to_i
  secs = a[2].to_f
  return ( hours * 3600 + minutes * 60 + secs )
end


def final_report( sequence_frames, fps, transition_and_timing, keep )
  sequence_duration = sequence_frames / fps
  @logger.debug( "#{ sequence_frames } frames intended by numbers (#{ hours_minutes_seconds_verbose( sequence_duration ) })" )
  @logger.debug( "#{ @framecount -1 } frames written" )
  @logger.info( "Cinema Slideshow is #{ hours_minutes_seconds_verbose( ( @framecount - 1 ) / fps ) } long (#{ @source.length } image#{ 's' * ( @source.length == 1 ? 0 : 1 )} | #{ transition_and_timing.join(',').gsub(' ', '') } | #{ @framecount - 1 } frames | #{ fps } fps)" )
  @logger.info( "Pick up preview files at #{ @workdir }/" ) if ( keep == TRUE and @output_type != 'dcp' )
  @logger.info( "Pick up temporary files at #{ @workdir }/" ) if ( keep == TRUE and @output_type == 'dcp' )
  @logger.info( "Pick up DCP at #{ @dcpdir }" ) if @output_type == 'dcp'
end


def cleanup_workdir( keep )
  case keep
  when FALSE
    case @output_type
    when 'preview', 'fullpreview'
      @logger.info( "Removing preview files (Say '--keep' to keep them)" )
      `rm -rf #{ @workdir }`
      #unless @final_audio.nil?
      #  `rm #{ @final_audio }` # which lives in @assetsdir_audio, for now
      #end
    when 'dcp'
      @logger.info( "Removing temporary files (Say '--keep' to keep them)" )
      `rm -rf #{ @conformdir }`
      `rm -rf #{ @j2cdir }`
      if File.dirname( @dcpdir ) != @workdir
        `rm -rf #{ @workdir }`
      end
    end
  end
end


def get_timestamp
  #t = Time.now
  #[t.year, '%02d' % t.month, '%02d' % t.day, '%02d' % t.hour, '%02d' % t.min, '%02d' % t.sec].join('_')
  DateTime.now.to_s
end
timestamp = get_timestamp


# fit custom aspect ratios into the target container dimensions (1k for preview, 2k/4k for fullpreview/dcp)
def scale_to_fit_container( width, height, container_width, container_height )
  factor = container_height / container_width > height / width ? container_width / width : container_height / height
  @logger.debug( "Scaling factor to fit custom aspect ratio #{ width } x #{ height } in #{ @size } container: #{ factor }" )
  width_scaled = width * factor
  height_scaled = height * factor
  return width_scaled.floor, height_scaled.floor
end


# target container dimensions are upscaled from 1k numbers
# (1k for preview, 2k and 4k for fullpreview and dcp)
# any custom aspect ratio is scaled to fit the target container
def width_x_height
  container_multiplier = @size.split( '' ).first.to_i
  container_width = 1024.0 * container_multiplier
  container_height = 540.0 * container_multiplier
  @logger.debug( "Container: #{ container_width } x #{ container_height } (1k multiplier: #{ container_multiplier })" )
  case @aspect
  when 'flat' # 1.85 : 1
    width, height = 999, 540 # 1.85
  when 'scope' # 2.39 : 1
    width, height = 1024, 429 # 2.38694638694639
  when 'hd' # 1.77 : 1
    width, height = 960, 540 # 1.77777777777778
  else # Custom aspect ratio
    custom_width, custom_height = @aspect.split( 'Custom aspect ratio:' ).last.split( 'x' )
    width, height = scale_to_fit_container( custom_width.to_f, custom_height.to_f, container_width, container_height )
    return [ width, height ].join( 'x' )
  end
  width *= container_multiplier
  height *= container_multiplier
  return [ width, height ].join( 'x' )
end


def make_black_sequence( info, duration, fps )
  @logger.info( "Black #{ info }: #{ duration } seconds" )
  blackfile = sequencefile
  make_black_frame( blackfile, fps )
  @framecount += 1
  sequence_links_to( blackfile, duration, fps )
end


def make_black_frame( filename, fps )
  black_asset = File.join( @assetsdir, 'black.' + @output_format )
  asset, todo = check_for_asset( black_asset, @output_format, fps )
  if todo == TRUE
    case @output_type
    when 'preview', 'fullpreview'
      `convert -type TrueColor -size #{ @dimensions } xc:black -depth 8 #{ asset }`
    when 'dcp'
      `convert -type TrueColor -size #{ @dimensions } xc:black -depth 12 #{ asset }`
    end
  end
  File.symlink( asset, filename )
end


def fade_in_hold_fade_out( image, fps, fade_in_time, duration, fade_out_time )
  if fade_in_time > 0
    fade_in( image, fps, fade_in_time )
  end
  if duration > 0
    full_level( image, fps, duration )
  end
  if fade_out_time > 0
    fade_out( image, fps, fade_out_time )
  end
end


def fade_in( image, fps, fade_in_time )
  @logger.info( ">>> Fade in #{ imagecount_info( image ) }" )
  initial = -100.0
  final = 0.0
  step = 100 / ( fade_in_time * fps )
  fade( image, fade_in_time, fps, initial, final, step )
end


def fade_out( image, fps, fade_out_time )
  @logger.info( "<<< Fade out #{ imagecount_info( image ) }" )
  initial = 0.0
  final = -100.0
  step = - ( 100 / ( fade_out_time * fps ) )
  fade( image, fade_out_time, fps, initial, final, step )
end


def fade( image, seconds, fps, initial, final, step )
  if step > 0 # fade in
    ladder = ( initial .. final ).step( step ).collect
  else # fade out
    ladder = ( final .. initial ).step( step.abs ).collect
  end
  ladder[ -1 ] = 0 # sic. float implementation, tighten the nut
  levels = ladder.collect { |rung| sigmoid( rung, initial, final, -50, 0.125 ) }
  if levels.first < -50
    levels[ 0 ] = -100
    levels[ -1 ] = 0
  else
    levels[ 0 ] = 0
    levels[ -1 ] = -100
  end
  @logger.debug( "levels: #{levels.inspect}" )
  #
  # levels has 1 element more than the number of steps provided by the following range
  # so the last element never gets applied -- 
  # hence the shifted fade symmetry (by 1 step).
  # 
  ( 1..( seconds * fps ) ).each do |i|
    filename = sequencefile
    level = levels[ i - 1 ]
    @logger.cr( sprintf( '%.2f', level ) )
    asset, todo = check_for_asset( image, @output_format, fps, level )
    if todo == TRUE
      convert_apply_level( image, level, asset )
    end
    File.symlink( asset, filename )
    @framecount += 1
  end
end


def sign( value )
  return ( value.to_f / value.to_f.abs ).to_i
end
def sigmoid( value, initial, final, center, rate )
  if initial > final
    base = final
  else
    base = initial
  end
  return ( initial - final ).abs / ( 1.0 + Math.exp( rate * sign( final - initial ) * ( -( value - center ).to_f ) ) ) + base
end


def crossfade( image1, image2, fps, seconds )
  @logger.info( "XXX Crossfade #{ imagecount_info( image1 ) }" )
  initial = 100.0
  final = 0.0
  step = - ( 100 / ( seconds * fps ) )
  ladder = ( final .. initial ).step( step.abs ).collect
  levels = ladder.collect { |rung| sigmoid( rung, initial, final, 50, 0.125 ) }
  case @output_type
  when "dcp"
    compress = "-compress none"
    depth = "-depth 12"
  when "preview", "fullpreview"
    compress = ""
    depth = "-depth 8"
  end
  ( 1..( seconds * fps ) ).each do |i|
    filename = sequencefile
    level = levels[ i - 1 ]
    @logger.cr( sprintf( '%.2f', level ) )
    asset, todo = check_for_asset( [ image1, image2 ], @output_format, fps, level )
    if todo == TRUE
      composite( image1, level, image2, depth, compress, asset )
    end
    File.symlink( asset, filename )
    @framecount += 1
  end
end


def full_level( image, fps, duration )
  @logger.info( "--- Full level #{ imagecount_info( image ) }" )
  level = 0
  file = sequencefile
  File.symlink( image, file )
  if ( 1 ..( duration * fps - 1 ) ).none? # only 1 image needed
    @framecount += 1 # temporary fix for FIXME @framecount stumble (Errno::EEXIST) on first fade out frame with 0 or 1 frame full level settings, like with $ cinemaslides 01.jpg 02.jpg -x crossfade,1,0
    @logger.debug( "Skip sequence links: Only 1 image needed here" )
  else
    @framecount += 1
    sequence_links_to( file, duration, fps )
  end
end


def sequence_links_to( file, seconds, fps )
  ( 1..( seconds * fps - 1 ) ).each do # 1 file already written
    link = sequencefile
    # FIXME link available on all platforms?
    File.symlink( file, link )
    @framecount += 1
  end
end


def imagecount_info( image )
  "(#{ @imagecount } of #{ @source.length })"
end


def sequencefile
  File.join( @conformdir, "#{ '%06d' % @framecount }.#{ @output_format }" )
end


# asset match is based on a /conform's/ IM signature + dimensions + (level unless jpeg 2000 codestream requested) + (encoder + fps if jpeg 2000 codestream is requested) + suffix
def check_for_asset( filename_s, suffix, fps, level = nil )
  # 2 images from crossfade?
  if filename_s.size == 2
    id = `identify -format '%#' #{ filename_s[0] }`.chomp + '_' + `identify -format '%#' #{ filename_s[1] }`.chomp
    origin = [ File.basename( filename_s[ 0 ] ), File.basename( filename_s[ 1 ] ) ].join( ' X ' )
  else # not from crossfade
    if File.exists?( filename_s )
      id = `identify -format '%#' #{ filename_s }`.chomp
    else
      id = 'black'
    end
    origin = File.basename( filename_s )
  end
  assetname = File.join( @assetsdir, id + "_#{ @dimensions }_#{ @resize == TRUE ? 'r' : 'nr' }#{ level.nil? ? '' : '_' + level.to_s }#{ @output_type == 'dcp' ? suffix == 'j2c' ? '_' + @encoder_id + '_' + ( @dcp_wrap_stereoscopic == TRUE ? '48' : fps.floor.to_s ) : '' : '_pre' }_.#{ suffix }" )
  if File.exists?( assetname )
    @logger.debug( "Skip: Asset exists (#{ origin } -> #{ File.basename( assetname ) })" )
    todo = FALSE
  else
    todo = TRUE
  end
  return assetname, todo
end


# all fade/crossfade ops are based on these assets
def conform( image, fps )
  @logger.info( "Conform image: #{ image }" )
  asset, todo = check_for_asset( image, @output_format, fps )
  if todo == TRUE
    convert_resize_extent_color_specs( image, asset )
  end
  return asset
end


# scale and fit any image to container size. apply color specs if dcp target
def convert_resize_extent_color_specs( image, filename )
  case @output_type
  when "preview", "fullpreview"
    `convert #{image} \
        -type TrueColor \
        -alpha Off \
        -gamma 0.454545454545455 \
        #{ @resize == TRUE ? '-resize ' + @dimensions : '' } \
        -background black \
        -gravity center \
        -extent #{ @dimensions } \
        -gamma 2.2 \
        -depth 8 \
        -strip \
        -sampling-factor 2x2 \
      #{ filename }`
  # kakadu needs uncompressed 12bpc files # FIXME dep compress on options.encoder
  when "dcp"
    `convert #{image} \
        -type TrueColor \
        -alpha Off \
        -gamma 0.454545454545455 \
        #{ @resize == TRUE ? '-resize ' + @dimensions : '' } \
        -background black \
        -gravity center \
        -extent #{ @dimensions } \
        -recolor '#{ SRGB_TO_XYZ }' \
        -gamma 2.6 \
        -depth 12 \
        -compress none \
      #{ filename }`
  else # hello typo
    puts "Use '-t preview' (half size) or '-t fullpreview' (full size) or '-t dcp'.\nDefaults to 'preview'."
    exit
  end
end


# image is already conformed, just apply level here
def convert_apply_level( image, level, filename )
  case @output_type
  when "preview", "fullpreview"
    `convert #{image} \
        -type TrueColor \
        -gamma 0.454545454545455 \
        #{ fadetype( level ) } \
        -gamma 2.2 \
      #{ filename }`
  when "dcp" # -compress none for kakadu
    `convert #{image} \
        -type TrueColor \
        -gamma 0.38461538461538458 \
        #{ fadetype( level ) } \
        -gamma 2.6 \
        -depth 12 \
        -compress none \
      #{ filename }`
  end
end


def fadetype( level )
  "-fill black -colorize #{ level.abs }"
  # composite source -size [source's size] xc:black -blend level.abs result
  #"-modulate #{ level + 100 }"#,#{ level + 100 }" # second parameter is saturation. this one has channel clipping issues
  #"-modulate #{ level + 100 } -blur 0x#{ level }" # experiment, color starvation -> heavy banding
  #"-brightness-contrast #{ level }x#{ level }" # not in ubuntu 10.04's im 6.5.7-8, rolls off into crushed blacks
end


def composite( image1, level, image2, depth, compress, output ) # -compress none for kakadu
  `composite -type TrueColor #{ image1 } -dissolve #{ level } #{ image2 } #{ depth } #{ compress } #{ output }`
end


def jpeg2000_dcp_rate_constraints( fps ) # returns bytes
  dcp_max_bps = 250000000
  max_per_image = ( dcp_max_bps / 8 / fps ).floor
  max_per_component = ( max_per_image / 1.25 ).floor
  return max_per_image, max_per_component
end


def sequence?( list )
  nil
end


def confirm_or_create( location )
# location (a directory) might exist and be either writeable or not.
# it might not exist and be either writeable (read 'can be created') or not.
# since we want to be able to specify a "deep" path (topdir/with/children/...) File.writable?() wouldn't work.
  testfile = File.join( location, `kmuuidgen -n` )
  if File.exists?( location )
    begin
      result = `touch #{ testfile } > /dev/null 2>&1`
      File.delete( testfile )
      return TRUE # location exists and we can write to it
    rescue Exception => result
      return FALSE # location exists but we can't write to it
    end
  else
    begin
      result = FileUtils.mkdir_p( location )
      return TRUE # location created, hence writeable
    rescue Exception => result
      return FALSE
    end
  end
end

class MXF_Metadata < Hash
    def initialize( mxf )
      asdcp_info = `asdcp-test -v -i #{ mxf }`.chomp
      if asdcp_info =~ /File essence type is JPEG 2000/ # ... (stereoscopic)? pictures
        asdcp_info = asdcp_info.split( /\n-- JPEG 2000 Metadata --/ ).first
      end
      asdcp_info = asdcp_info.split( /\n\s*/ )
      @meta = Hash.new
      asdcp_info.each do |line|
        key, value = line.split( ': ' )
        @meta[ key ] = value
      end
    end
    def hash
      @meta
    end
end # MXF_Metadata


class CPL_SMPTE_429_7_2006
  def initialize( cpl_uuid, image_mxfs, audio_mxfs, annotation, issue_date, issuer, creator, content_title, content_kind, content_version_id, content_version_label, rating_list )
    @builder = Nokogiri::XML::Builder.new( :encoding => 'UTF-8' ) do |xml|
      xml.CompositionPlaylist_( :xmlns => 'http://www.smpte-ra.org/schemas/429-7/2006/CPL' ) {
        xml.Id_ "urn:uuid:#{ cpl_uuid }"
        xml.AnnotationText_ annotation
        xml.IssueDate_ issue_date
        xml.Issuer_ issuer
        xml.Creator_ creator
        xml.ContentTitleText_ content_title
        xml.ContentKind_ content_kind
        xml.ContentVersion_ {
          xml.Id_ "urn:uri:#{ content_version_id }"
          xml.LabelText_ content_version_label
        } # ContentVersion
        xml.RatingList_ "#{ rating_list.nil? ? '' : rating_list }"
        xml.ReelList_ {
          image_mxfs.each_with_index do |image_mxf, index| # assume image_mxfs.size == audio_mxfs.size
            image_meta = MXF_Metadata.new( image_mxf ).hash
            audio_meta = MXF_Metadata.new( audio_mxfs[ index ] ).hash unless audio_mxfs.nil?
            xml.Reel_ {
              xml.Id_ "urn:uuid:#{ `kmuuidgen -n` }" # FIXME
              xml.AssetList_ {
                if image_meta.has_key?( 'File essence type is JPEG 2000 stereoscopic pictures.' )
                  xml.MainStereoscopicPicture_( 'xmlns:msp-cpl' => 'http://www.smpte-ra.org/schemas/429-10/2008/Main-Stereo-Picture-CPL' ) {
                    xml.Id_ "urn:uuid:#{ image_meta[ 'AssetUUID' ] }"
                    xml.EditRate_ image_meta[ 'EditRate' ].to_s.gsub( '/', ' ' )
                    xml.IntrinsicDuration_ image_meta[ 'ContainerDuration' ]
                    xml.EntryPoint_ 0 # FIXME
                    xml.Duration_ image_meta[ 'ContainerDuration' ] # FIXME
                    xml.FrameRate_ image_meta[ 'SampleRate' ].to_s.gsub( '/', ' ' ) # FIXME SampleRate?
                    xml.ScreenAspectRatio_ image_meta[ 'AspectRatio' ].to_s.gsub( '/', ' ' )
                  } # MainStereoscopicPicture
                else
                  xml.MainPicture_ {
                    xml.Id_ "urn:uuid:#{ image_meta[ 'AssetUUID' ] }"
                    xml.EditRate_ image_meta[ 'EditRate' ].to_s.gsub( '/', ' ' )
                    xml.IntrinsicDuration_ image_meta[ 'ContainerDuration' ]
                    xml.EntryPoint_ 0 # FIXME
                    xml.Duration_ image_meta[ 'ContainerDuration' ] # FIXME
                    xml.FrameRate_ image_meta[ 'SampleRate' ].to_s.gsub( '/', ' ' ) # FIXME SampleRate?
                    xml.ScreenAspectRatio_ image_meta[ 'AspectRatio' ].to_s.gsub( '/', ' ' )
                  } # MainPicture
                end
                unless audio_mxfs.nil?
                  xml.MainSound_ {
                    xml.Id_ "urn:uuid:#{ audio_meta[ 'AssetUUID' ] }"
                    xml.EditRate_ audio_meta[ 'EditRate' ].to_s.gsub( '/', ' ' )
                    xml.IntrinsicDuration_ audio_meta[ 'ContainerDuration' ]
                    xml.EntryPoint_ 0 # FIXME
                    xml.Duration_ audio_meta[ 'ContainerDuration' ].to_s.gsub( '/', ' ' ) # FIXME
                  } # MainSound
                end
              } # AssetList
            } # Reel
          end # image_mxfs.each
        } # ReelList
      } # CompositionPlaylist
    end # Builder
  end # initialize
    
  def xml
    return @builder.to_xml( :indent => 2 )
  end
  
  def check_reels
    nodes = Nokogiri::XML::Document.parse( @builder.to_xml )
    reels = nodes.xpath( '//xmlns:CompositionPlaylist/xmlns:ReelList/xmlns:Reel' )
    puts "Number of reels: #{ reels.size }"
    reels.each_with_index do |reel, index|
      puts "Reel # #{ index + 1 }:"
      puts "Image MXF Id => #{ reel.search( 'AssetList/MainPicture/Id' ).text }"
      puts "Sound MXF Id => #{ reel.search( 'AssetList/MainSound/Id' ).text }"
    end
  end # check_reels
end # CPL_SMPTE_429_7_2006


class PKL_SMPTE_429_8_2007
  def initialize( pkl_uuid, annotation, issue_date, issuer, creator, assets )
    @builder = Nokogiri::XML::Builder.new( :encoding => 'UTF-8' ) do |xml|
      xml.PackingList_( :xmlns => 'http://www.smpte-ra.org/schemas/429-8/2007/PKL' ) {
        xml.Id_ "urn:uuid:#{ pkl_uuid }"
        xml.AnnotationText_ annotation
        xml.IssueDate_ issue_date
        xml.Issuer_ issuer
        xml.Creator_ creator
        xml.AssetList_ {
          assets.each do |asset|
            fh = File.open( asset, 'r' )
            fh_line = fh.read( 19 )
            fh.close
            if fh_line =~ /^<\?xml version="1.0"/
              mimetype = 'text/xml'
              asset_uuid = Nokogiri::XML( File.open( asset ) ).xpath( "//xmlns:CompositionPlaylist/xmlns:Id" ).text.split( 'urn:uuid:' ).last
            else
              mimetype = 'application/mxf'
              metadata = MXF_Metadata.new( asset ).hash
              asset_uuid = metadata[ 'AssetUUID' ]
            end
            sha1_digest_base64 = `asdcp-test -t #{ asset }`.split( ' ' ).first
            xml.Asset_ {
              xml.Id_ "urn:uuid:#{ asset_uuid }"
              # optional: AnnotationText per asset
              xml.Hash_ sha1_digest_base64 # FIXME Base64.encode64( Digest::SHA1.digest( File.read( asset ) ) ).chomp
              xml.Size_ File.size( asset )
              xml.Type_ mimetype
              xml.OriginalFileName_ File.basename( asset )
            } # Asset
          end # assets.each
        } # AssetList
      } # PackingList
    end # @builder
  end # initialize
  
  def xml
    return @builder.to_xml( :indent => 2 )
  end
end # PKL_SMPTE_429_8_2007


class AM_SMPTE_429_9_2007
  def initialize( am_uuid, issue_date, issuer, creator, assets )
    @builder = Nokogiri::XML::Builder.new( :encoding => 'UTF-8' ) do |xml|
      xml.AssetMap_( :xmlns => 'http://www.smpte-ra.org/schemas/429-9/2007/AM' ) {
        xml.Id_ "urn:uuid:#{ am_uuid }"
        xml.Creator_ creator
        xml.VolumeCount_ '1' # FIXME
        xml.IssueDate_ issue_date
        xml.Issuer_ issuer
        xml.AssetList_ {
          assets.each do |asset|
            fh = File.open( asset, 'r' )
            fh_line = fh.read( 19 )
            fh.close
            if fh_line =~ /^<\?xml version="1.0"/
              doc = Nokogiri::XML::Document.parse( File.read( asset ) )
              if doc.search( "//xmlns:PackingList" ).empty? # FIXME assume CPL
                packing_list = FALSE
                asset_uuid = Nokogiri::XML( File.open( asset ) ).xpath( "//xmlns:CompositionPlaylist/xmlns:Id" ).text.split( 'urn:uuid:' ).last
              else
                packing_list = TRUE
                asset_uuid = Nokogiri::XML( File.open( asset ) ).xpath( "//xmlns:PackingList/xmlns:Id" ).text.split( 'urn:uuid:' ).last
              end # PackingList?
            else # MXF
              metadata = MXF_Metadata.new( asset ).hash
              asset_uuid = metadata[ 'AssetUUID' ]
            end
            
            xml.Asset_ {
              xml.Id_ "urn:uuid:#{ asset_uuid }"
              if packing_list == TRUE
                xml.PackingList_ 'true'
              end
              xml.ChunkList_ {
                xml.Chunk_ {
                  xml.Path_ File.basename( asset )
                  # optional: VolumeIndex
                  # optional: Offset
                  # optional: Length
                } # Chunk
              } # ChunkList
            } # Asset
          end # assets.each
        } # AssetList
      } # AssetMap
    end # @builder
  end # initialize
  
  def xml
    return @builder.to_xml( :indent => 2 )
  end
end # AM_SMPTE_429_9_2007
###


@logger.debug( commandline )


available_tools, missing_tools = check_requirements( requirements )
if options.output_type == "dcp"
  if missing_tools.include?( "kdu_compress" )
    if missing_tools.include?( "image_to_j2k" ) # both openjpeg and kakadu not available
      @logger.warn( "No JPEG 2000 codec available (Needed for DCP creation). Check your installation." )
    elsif options.encoder == "kakadu" # openjpeg is available, kakadu is not
      options.encoder = "openjpeg"
      @logger.warn( "kakadu's kdu_compress is not available. Falling back to openjpeg" )
    end
  elsif missing_tools.include?( "image_to_j2k" ) # kakadu is available, openjpeg is not
    if options.encoder == "openjpeg"
      options.encoder = "kakadu"
      @logger.warn( "openjpeg's image_to_j2k is not available. Falling back to kakadu" )
    end
  end
end
# boy-oh-boy-oh-boy
if available_tools.size < requirements.size - 1 # all tools needed minus 1 codec alternative
  @logger.info( "Missing tools: #{ missing_tools.join(', ') }" ) unless missing_tools.empty?
  @logger.warn( "Check your tools" )
  exit
end
@logger.debug( "Available tools: #{ available_tools.sort.join(', ') }" ) unless available_tools.empty?
@logger.debug( "Missing tools: #{ missing_tools.join(', ') }" ) unless missing_tools.empty?
@logger.debug( "All necessary tools available" ) if missing_tools.empty? # FIXME


### Get options and initialize
black_leader = black_tail = options.black
black_leader = options.black_leader.abs unless options.black_leader.nil?
black_tail = options.black_tail.abs unless options.black_tail.nil?

@resize = options.resize

case options.aspect_malformed
when TRUE
  @logger.info( "Malformed aspect ratio. Use #{ options.aspect_choices[ 0, options.aspect_choices.size - 1 ].join( ', ' ) } or <width>x<height>" )
  exit
when FALSE
  @aspect = options.aspect
  w, h = @aspect.split( 'Custom aspect ratio: ' ).last.match( options.aspect_choices.last ).to_s.split( 'x' )
  if ! h.nil?
    if w.to_f == 0 or h.to_f == 0
      @logger.info( "Zero in aspect ratio specs. Doesn't compute" )
      exit
    end
  end
end

m = options.size.match( /catch:(.*)/ )
unless m.nil?
  if [ 'eep', 'ind' ].include?( m[1] )
    @logger.info( "Did you mean to say '--k#{ m[ 1 ] }'?" )
  else
    @logger.info( "Can't understand -k's argument: '#{ m[ 1 ] }'. Use #{ options.size_choices.join( ' or ' ) }" )
  end
  exit
end

m = options.output_type.match( /catch:(.*)/ )
unless m.nil?
  @logger.info( "Specify output type: preview, fullpreview or dcp" )
  exit
end

@output_type = options.output_type
case @output_type
when 'preview'
  @size = '1k'
else
  @size = options.size
end


# check dcp related options
@dcp_wrap_stereoscopic = options.dcp_wrap_stereoscopic
if @output_type == "dcp"
  unless options.encoder_choices.include?( options.encoder )
    @logger.critical( "Not a usable encoder: '#{ options.encoder }'" )
    exit
  end
  # mark assets with encoder ids
  case options.encoder
  when 'openjpeg'
    @encoder_id = 'opj'
  when 'kakadu'
    @encoder_id = 'kdu'
  else
    @encoder_id = 'xxx' # FIXME
  end
  if ! options.fps_dcp_choices.include?( options.fps )
    if options.fps_asdcp_choices.include?( options.fps )
      @logger.critical( "DCI compliant framerate but not yet implemented in #{ File.basename( $0 ) }: #{ options.fps } fps" )
      exit
    else
      @logger.critical( "Not a DCI compliant framerate: #{ options.fps } fps" )
      exit
    end
  end
  if options.output_type == 'dcp' and @dcp_wrap_stereoscopic == TRUE and options.fps != 24
    @logger.info( "Option '--wrap-stereoscopic' is set -> Setting fps to 24" )
    options.fps = 24.0
  end
  @logger.debug( "DCP related options ok" )
end


# check provided files for readability, type and validity
# come up with 3 lists: image files, audio files, unusable files
@source = ARGV
@source_audio = Array.new
if options.dont_check == TRUE ####
  if @source.empty?
    @logger.info( 'No files specified' )
    exit
  end
else # check files
  # remove un-readable elements
  not_readable = Array.new
  @source_tmp = Array.new
  @source.each do |element|
    if File.exists?( element )
      ftype = File.ftype( element )
      if ftype == 'directory'
        more = Dir.glob( "#{ element }/*" ).sort # this breaks fast (subdirs)
        @source_tmp << more
      else
        @source_tmp << element
      end
    else
      not_readable << element
      @logger.debug( "Not readable: #{ element }" )
    end
  end
  @source = @source_tmp.flatten.compact.dup
  
  # check type (image/audio)
  no_decode_delegate = Array.new
  drops = FALSE
  @source_tmp = @source.clone
  @source.each do |file|
    image_identify = `identify -format '%m' #{ file } 2>/dev/null`.chomp
    if image_identify.empty?
      audio_identify = `soxi -V0 -t #{ file }`.chomp
      if audio_identify.empty?
        no_decode_delegate << file
        @source_tmp.delete( file )
        @logger.debug( "#{ file }: No decode delegate" )
      else
        @source_audio << file
        @source_tmp.delete( file )
        audiofile_duration = '(' + `soxi -V0 -d #{ file }`.chomp + ')'
        @logger.debug( "#{ audio_identify.upcase } #{ audiofile_duration }: #{ file }" )
      end
    # see http://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=16398
    # basically IM defers deep analysis of xml to the coder
    # the lightweight identify ping of xml might return false positives
    elsif image_identify == "SVG"
      xml = Nokogiri::XML( File.open( file ) )
      if xml.search( 'svg', 'SVG' ).empty?
        no_decode_delegate << file
        @source_tmp.delete( file )
        @logger.debug( "No <svg> node: #{ file }" )
      else # svg maybe useable
        @logger.debug( "#{ image_identify }: #{ file }" )
      end
    else # file is useable
      dimensions = `convert #{ file } -format '(%wx%h, 1:%[fx:w/h])' info:`.chomp
      @logger.debug( "#{ image_identify } #{ dimensions }: #{ file }" )
    end
  end
  if not_readable.size > 0
    drops = TRUE
    @logger.debug( "Not readable: #{ not_readable.join( ', ' ) }" )
  elsif not_readable.size == 0 and @source_tmp.size > 0
    @logger.debug( "All files readable" )
  end
  if no_decode_delegate.size > 0
    drops = TRUE
    @logger.debug( "No decode delegates for #{ no_decode_delegate.join( ', ' ) }" )
  end
  if @source_tmp.length == 0
    @logger.info( drops == FALSE ? "No image files specified" : "No useable image files")
    exit
  end
  if drops == TRUE
    if options.dont_drop == TRUE
      exit
    else
      @logger.debug( "Dropped some unuseable files. Say '--dont-drop' to exit in that case." )
    end
  end
  @source = @source_tmp.dup
end

if options.dont_check == TRUE
  # quick and dirty version of audio file pickup (which is the whole point of --dont-check)
  @source_audio = Array.new
  @source_tmp = @source.clone
  @source.each do |element|
    if element =~ /(mp3|MP3|wav|WAV|flac|FLAC|aiff|AIFF|aif|AIF|ogg|OGG)$/
      @source_audio << element
      @source_tmp.delete( element )
    end
  end
  @source = @source_tmp.clone
end

@logger.debug( "Images: #{ @source.join( ', ' ) }" )
@logger.debug( "Audio files: #{ @source_audio.join( ', ' ) }" )
@logger.debug( "No decode delegates for: #{ no_decode_delegate.nil? ? 'Not checked' : no_decode_delegate.join( ', ' ) }" )


# check options.transition_and_timing
options.transition_and_timing.first.downcase!
if options.transition_and_timing.first == 'fade' and options.transition_and_timing.length == 4
  fade_in_time = options.transition_and_timing[1].to_f
  duration = options.transition_and_timing[2].to_f
  fade_out_time = options.transition_and_timing[3].to_f
elsif options.transition_and_timing.first == 'cut' and options.transition_and_timing.length == 2
  fade_in_time = 0
  duration = options.transition_and_timing[1].to_f
  fade_out_time = 0
elsif options.transition_and_timing.first == 'crossfade' and options.transition_and_timing.length == 3
  crossfade_time = options.transition_and_timing[1].to_f
  duration = options.transition_and_timing[2].to_f
  if @source.length == 1
    @logger.warn( "Can't crossfade 1 image (#{ @source.first })" )
    @logger.info( "Either supply more than 1 image or change transition_and_timing to fade specs ('-x fade,a,b,c')" )
    exit
  end
else
  @logger.warn( "Malformed transition and timing specs" )
  @logger.info( "Use '-x fade,a,b,c' or '-x crossfade,a,b' or '-x cut,b' (a = fade in time/crossfade time, b = full level time, c = fade out time)" )
  exit
end


fps = options.fps
@framecount = 1
@imagecount = 0
if @output_type == "dcp"
  @output_format = "tiff"
  original_suffix = @output_format
  SRGB_TO_XYZ = "0.4124564 0.3575761 0.1804375 0.2126729 0.7151522 0.0721750 0.0193339 0.1191920 0.9503041"
else
  @output_format = options.output_format
end


# calculate intended number of frames including black leader and tail, needed in audio conform and final report
if options.transition_and_timing.first == "fade" or options.transition_and_timing.first == 'cut'
  sequence_frames = ( ( black_leader + black_tail ) + @source.length * ( fade_in_time + duration + fade_out_time ) ) * fps
elsif options.transition_and_timing.first == "crossfade"
  sequence_frames = ( ( black_leader + black_tail ) + crossfade_time + @source.length * ( crossfade_time + duration ) ) * fps # implicit fade in/out first/last when crossfading
end
# meat of sequence_frames (without black leader/tail) -- where audio will play
image_sequence_frames = sequence_frames - ( ( black_leader + black_tail ) * fps )


# set up diretories to write output to. These locations are created upon demand only,
# hence the mkdir's are clustered out a bit. FIXME
CINEMASLIDESDIR = ENV['CINEMASLIDESDIR']
if CINEMASLIDESDIR.nil?
  @cinemaslidesdir = File.join( ENV[ 'HOME' ], "cinemaslidesdir" )
  @logger.debug( "CINEMASLIDESDIR not set. Will use #{ @cinemaslidesdir }" )
else
  @logger.debug( "CINEMASLIDESDIR is set to #{ CINEMASLIDESDIR }" )
  @cinemaslidesdir = CINEMASLIDESDIR
end
@workdir = File.join( @cinemaslidesdir, "#{ File.basename( $0 ) }_#{ timestamp }_#{ @output_type }" )
@conformdir = File.join( @workdir, "conform" )
@j2cdir = File.join( @workdir, "j2c" )
@thumbsdir = File.join( @cinemaslidesdir, "thumbs" )
@assetsdir = File.join( @cinemaslidesdir, "assets" )
@assetsdir_audio = File.join( @cinemaslidesdir, 'assets-audio' )

if confirm_or_create( @cinemaslidesdir ) == TRUE
  @logger.debug( "#{ @cinemaslidesdir } is writeable" )
else
  @logger.critical( "#{ @cinemaslidesdir } is not writeable. Check your mounts or export CINEMASLIDESDIR to point to a writeable location." )
  exit
end
unless @source.empty? # TODO audio-only DCP
  Dir.mkdir( @assetsdir ) unless File.exists?( @assetsdir )
end
unless @source_audio.empty?
  Dir.mkdir( @assetsdir_audio ) unless File.exists?( @assetsdir_audio )
end
if options.dcp_user_output_path == nil
  @dcpdir = File.join( @workdir, "dcp" )
else
  @dcpdir = options.dcp_user_output_path
end
case @output_type
when 'dcp' # silently ignore option.dcp_user_output_path when previewing
  # ask for confirmation to add files if -o | --dcp_out is set and the location already exists and is not empty
  if options.dcp_user_output_path != nil and File.exists?( @dcpdir ) and Dir.entries( @dcpdir ).size > 2 # platform-agnostic Dir.empty? anyone?
    if File.writable?( @dcpdir )
      if ENV[ 'HOME' ] == File.join( File.dirname( @dcpdir ), File.basename( @dcpdir ) ) # confirm direct write into HOME
        @logger.critical( "Cluttering HOME" )
        exit if agree( "Are you sure you want to write DCP files directly into #{ ENV[ 'HOME' ] }? " ) == FALSE
      else
        exit if agree( "#{ @dcpdir } already exists. Add current DCP files to it? " ) == FALSE
      end
    end
  end
  if confirm_or_create( @dcpdir ) == TRUE
    @logger.debug( "#{ @dcpdir } is writeable" )
  else
    @logger.critical( "#{ @dcpdir } is not writeable. Check your mounts and permissions." )
    exit
  end
end
###


@dimensions = width_x_height
x,y = @dimensions.split( 'x' ) # ugh
x = x.to_i / 6 # ugh ugh
y = y.to_i / 6 # ...
@thumbs_dimensions = [ x,y ].join( 'x' ) # oh dear


case @output_type
when "dcp"
  @logger.info( "Creating #{ @dcp_wrap_stereoscopic == TRUE ? '3D' : '2D' } #{ @size.upcase } DCP (#{ @aspect } #{ @dimensions } @ #{ fps } fps). Encoder: #{ options.encoder }" )
  @logger.info( "Projected length: #{ hours_minutes_seconds_verbose( sequence_frames / fps ) }" )
  @logger.info( "Title:      #{ options.dcp_title }" )
  @logger.info( "Annotation: #{ options.dcp_annotation }" )
  @logger.info( "Issuer:     #{ options.dcp_issuer }" )
  @logger.info( "Kind:       #{ options.dcp_kind }" )
when "preview", "fullpreview"
  @logger.info( "Creating #{ @output_type } (#{ @aspect } #{ @dimensions } @ #{ fps } fps)" )
  @logger.info( "Projected length: #{ hours_minutes_seconds_verbose( sequence_frames / fps ) }" )
end


### Process audio (asset-audio depot is still a moving target, bugs lurking etc., as of v0.2010.09.07)
#
# user can specify -- alongside with any number of images -- any number of audio files
# a) cinemaslides makes a list which will be equally long as or longer than the calculated image sequence
#    when the total length of the specified audio files is not long enough the list-making process will start over until length is sufficient
#    (e.g. user specifies [a.wav b.wav c.wav] with 1 min total length, image sequence is 1:30 min, audio list will be [a.wav b.wav c.wav a.wav ...]
#     and will be trimmed to 1:30 min)
# b) every element of the list is then checked into the asset depot
# c) the elements are spliced together (result is checked into asset depot)
# d) the result is trimmed to the exact length of the image sequence
# e) the result is padded with silence to accomodate for black leader/tail
def conform_audio( audiofile, samplerate, bps, channelcount )
  @logger.info( "Conform audio: #{ audiofile }" )
  asset, todo = check_for_audio_asset( audiofile, samplerate, bps, channelcount )
  if todo == TRUE
    sox_conform( audiofile, samplerate, bps, channelcount, asset )
  end
  return asset
end


def check_for_audio_asset( filename, samplerate, bps, channelcount )
  hexdigest = Digest::SHA1.hexdigest( File.read( filename ) )
  assetname = File.join( @assetsdir_audio, "#{ hexdigest }_#{ samplerate }_#{ bps }_#{ channelcount }_.wav" )
  if File.exists?( assetname )
    @logger.debug( "Skip: Audio asset exists (#{ filename } -> #{ File.basename( assetname ) })" )
    todo = FALSE
  else
    todo = TRUE
  end
  return assetname, todo
end


def sox_conform( audiofile, samplerate, bps, channelcount, asset ) # and normalise to -20 dB FS (SMPTE 428-2-2006)
  `sox #{ audiofile } -r #{ samplerate } -b #{ bps } -c #{ channelcount } -s -t wavpcm #{ asset } gain -n -20`
end


def silence( seconds, samplerate, bps, channelcount )
  silence_conform = File.join( @assetsdir_audio, 'silence_' + seconds.to_s + '_' + samplerate.to_s + '_' + bps.to_s + '_' + channelcount.to_s + '.wav' )
  if File.exists?( silence_conform )
    @logger.debug( "Skip: Silence asset exists (#{ File.basename( silence_conform ) })" )
  else
    # alternatively, use asdcplib's blackwave (blackwave -d <frame_count> output)
    `sox -r #{ samplerate } -b #{ bps } -c #{ channelcount } -s -n #{ silence_conform } synth #{ seconds } sine 0`
  end
  return silence_conform
end


unless @source_audio.empty?
  @logger.info( 'Conform audio ...' )
  
  audio_list = Array.new
  audio_list_total_length = 0.0
  conformed_audio_list = Array.new
  source_audio_index = 0
  
  image_sequence_length_seconds = image_sequence_frames / fps
  image_sequence_length_hms = hms_from_seconds( image_sequence_length_seconds ) #  needed for sox/trim
  
  # a) make a list of audiofiles with sufficient total length (read 'at least as long as image sequence')
  while audio_list_total_length < image_sequence_length_seconds
    audio_list << @source_audio[ source_audio_index ]
    audio_list_total_length += `soxi -D #{ @source_audio[ source_audio_index ] }`.chomp.to_f
    if source_audio_index == @source_audio.size - 1
      source_audio_index = 0 # start over
    else
      source_audio_index += 1
    end
  end
  
  # b) conform the required audiofiles
  audio_list.each do |audiofile|
    audio_asset = conform_audio( audiofile, options.audio_samplerate, options.audio_bps, 2 ) # FIXME channelcount
    conformed_audio_list << audio_asset
  end
  
  # match for sequence_audio_asset is based on image sequence length and sha1 digest of conformed_audio_list's elements (assets) joined into 1 string
  set = Array.new
  conformed_audio_list.each do |e|
    set << File.basename( e )
  end
  sequence_audio_asset = File.join( @assetsdir_audio, "#{ Digest::SHA1.hexdigest( set.join ) }_sequence_#{ image_sequence_length_seconds }_.wav" )
  
  # c) splice
  sequence_audio_asset_tmp = File.join( @assetsdir_audio, 'tmp-' + File.basename( sequence_audio_asset ) )
  `sox #{ conformed_audio_list.join( ' ' ) } #{ sequence_audio_asset_tmp } splice`

  # d) trim
  if File.exists?( sequence_audio_asset )
    @logger.debug( "Skip: Trimmed audio asset for image sequence exists (#{ File.basename( sequence_audio_asset ) })" )
  else
    @logger.debug( 'Trim audio' )
    `sox #{ sequence_audio_asset_tmp } #{ sequence_audio_asset } trim 0 #{ image_sequence_length_hms }`
  end
  File.delete( sequence_audio_asset_tmp )
  
  # e) pad with silence for black leader/tail
  audio_leader = ( black_leader > 0 ? silence( black_leader, options.audio_samplerate, options.audio_bps, 2 ) : '' )
  audio_tail = ( black_tail > 0 ? silence( black_tail, options.audio_samplerate, options.audio_bps, 2 ) : '' )
  if black_leader + black_tail > 0
    @logger.debug( 'Pad audio with leader/tail silence' )
    @final_audio = File.join( @assetsdir_audio, 'padded_' + File.basename( sequence_audio_asset ) )
    `sox #{ audio_leader } #{ sequence_audio_asset } #{ audio_tail } #{ @final_audio } splice`
  else
    @final_audio = sequence_audio_asset
  end
  
  @logger.info( '... Conform audio done' )
end
###

### Process all images

# thumbs and minimontage
if options.montage == TRUE
  Dir.mkdir( @thumbsdir ) unless File.exists?( @thumbsdir )
  @logger.info( "Create thumbnails" )
  thumbs = Array.new
  ( 0..( @source.length - 1 ) ).each do |i|
    thumbfile = File.join( @thumbsdir, Digest::MD5.hexdigest( File.read( @source[ i ] ) ) + "_#{ @thumbs_dimensions }_" + ".jpg" )
    if File.exists?( thumbfile )
      @logger.debug( "Skip: #{ File.basename( thumbfile ) } exists" )
      thumbs << thumbfile
      next
    else
      @logger.info( "Thumb for #{ @source[ i ] }" )
      `convert #{ @source[ i ] } \
         -type TrueColor \
         -resize #{ @thumbs_dimensions } \
         -background black \
         -gravity center \
         -extent #{ @thumbs_dimensions } \
         -depth 8 \
       #{ thumbfile }`
       thumbs << thumbfile
     end
  end
  thumbs = thumbs.join(' ')
  # cache montages, wacky-hacky using string of all thumbnail filenames (md5 hexdigest and some) to match
  thumbs_asset = File.join( @thumbsdir, Digest::MD5.hexdigest( thumbs ) + '_montage_.jpg' )
  if File.exists?( thumbs_asset )
    @logger.debug( "Skip: Montage exists (#{ File.basename( thumbs_asset ) })" )
  else
    tiles_x = Math.sqrt( @source.length ).ceil
    `montage #{ thumbs } \
       -mode Concatenate \
       -tile #{ tiles_x }x \
       -border 1 \
       -geometry '#{ x }x#{ y }+5+5>' \
       -bordercolor lightblue \
    #{ thumbs_asset }`
  end
  if ENV[ "DISPLAY" ].nil?
    @logger.warn( "DISPLAY not set. Skipping montage summary. #{ options.keep == TRUE ? nil : 'Say --keep to keep preview files.' }" )
  else
    @logger.warn( "Montage summary #{ @output_type }. Exit with ESC or 'q'" )
    `display #{ thumbs_asset }`
  end
  exit if agree( "Continue? " ) == FALSE
end # montage


### Create all frames
Dir.mkdir( @workdir ) unless File.exists?( @workdir )
Dir.mkdir( @conformdir )


# Create black leader
if black_leader > 0
  make_black_sequence( 'leader', black_leader, fps)
end

# Process all images
keeper = nil # keep a conform for the next crossfade (2nd will be 1st then, don't conform again)
@source.each_index do |index|
  case options.transition_and_timing.first
  when "fade", "cut"
    @imagecount += 1
    image = conform( @source[ index  ], fps )
    fade_in_hold_fade_out( image, fps, fade_in_time, duration, fade_out_time )
  when "crossfade"
    @imagecount += 1
    case index
    when 0 # first image
      image1 = conform( @source[ index ], fps )
      image2 = conform( @source[ index + 1 ], fps )
      keeper = image2
      fade_in( image1, fps, crossfade_time )
      full_level( image1, fps, duration )
      crossfade( image1, image2, fps, crossfade_time )
    when @source.length - 1 # last image
      image = keeper
      full_level( image, fps, duration )
      fade_out( image, fps, crossfade_time )
    else
      image1 = keeper
      image2 = conform( @source[ index + 1 ], fps )
      keeper = image2
      full_level( image1, fps, duration )
      crossfade( image1, image2, fps, crossfade_time )
    end
  end
end

# Create black tail
if black_tail > 0
  make_black_sequence( 'tail', black_tail, fps )
end
###


### Create preview/fullpreview
case @output_type
when "preview", "fullpreview"
  sequence = File.join( "#{ @conformdir }", "*.#{ @output_format }" )
  audio = ( @source_audio.empty? ? '' : '-audiofile ' + @final_audio )
  if ENV[ "DISPLAY" ].nil?
    @logger.warn( "DISPLAY not set. Skipping preview" )
  else
    @logger.warn( "Loop #{ @output_type }. Exit with ESC or 'q'" )
    mplayer_vo = ""
    `mplayer -really-quiet mf://#{ sequence } #{ audio } -mf fps=#{ fps }:type=#{ @output_format } -loop 0 #{ mplayer_vo } -vf eq2=#{ options.mplayer_gamma } > /dev/null 2>&1`
  end
  final_report( sequence_frames, fps, options.transition_and_timing, options.keep )
  cleanup_workdir( options.keep )
  @logger.info( "Preview done" )
  exit
###


### Create DCP (Encoding, asdcplib, XML)
when "dcp"
  Dir.mkdir( @j2cdir )

  ## JPEG 2000 encoding
  @logger.info( "Encode to JPEG 2000" )
  filemask = File.join( @conformdir, "*.#{ @output_format }" )
  files = Dir.glob( filemask ).sort
  
  # openjpeg's cinema profiles imply rate constraints, kakadu's don't
  max_bytes_per_image, max_bytes_per_component = jpeg2000_dcp_rate_constraints( @dcp_wrap_stereoscopic == TRUE ? 48.0 : fps )
  if @size == "2k"
    kakadu_cinema_profile = "CINEMA2K"
    openjpeg_cinema_profile = "cinema2K #{ @dcp_wrap_stereoscopic == TRUE ? 48 : fps }"
  elsif @size == "4k"
    kakadu_cinema_profile = "CINEMA4K"
    openjpeg_cinema_profile = "cinema4K"
  end
  
  counter = 0
  previous_asset = ""
  
  files.each do |file|
    counter += 1
    asset_link = file + '.j2c'
    if File.dirname( File.readlink( file ) ) == @conformdir # 1st file is always a link to the asset depot
      File.link( previous_asset, asset_link )
      @logger.cr( "Skip (Full level): #{ File.basename( file ) } (#{ counter } of #{ files.size })" )
    else
      asset, todo = check_for_asset( file, 'j2c', fps ) # possible "Skip" message only with debug verbosity
      previous_asset = asset
      if todo == TRUE
        @logger.cr( "#{ options.encoder }: #{ File.basename( file ) } (#{ counter } of #{ files.size })" )
        case options.encoder
        when 'openjpeg'
          `image_to_j2k -#{ openjpeg_cinema_profile } -i #{ file } -o #{ asset } > /dev/null 2>&1`
        when 'kakadu'
          `kdu_compress -i #{ file } -o #{ asset } Sprofile=#{ kakadu_cinema_profile } Creslengths=#{ max_bytes_per_image } Creslengths:C0=#{ max_bytes_per_image },#{ max_bytes_per_component } Creslengths:C1=#{ max_bytes_per_image },#{ max_bytes_per_component } Creslengths:C2=#{ max_bytes_per_image },#{ max_bytes_per_component }`
        end
      end
      File.link( asset, asset_link )
    end
  end

  `mv #{ File.join( @conformdir, '*.j2c' ) } #{ @j2cdir }`
  
  # Setup MXF container names
  image_mxf_uuid = `kmuuidgen -n`
  image_mxf = File.join( @dcpdir, "j2c_#{ image_mxf_uuid }_.mxf" )
  unless @source_audio.empty?
    audio_mxf_uuid = `kmuuidgen -n`
    audio_mxf = File.join( @dcpdir, "pcm_#{ audio_mxf_uuid }_.mxf" )
  end

  # Make image trackfile
  @logger.info( 'Write image trackfile ...' )
  if @dcp_wrap_stereoscopic == TRUE
    @logger.info( 'Wrap as stereoscopic essence' )
    `asdcp-test -L -E -a #{ image_mxf_uuid } -c #{ image_mxf } -3 #{ @j2cdir } #{ @j2cdir } > /dev/null 2>&1`
  else
    `asdcp-test -L -E -p #{ fps } -a #{ image_mxf_uuid } -c #{ image_mxf } #{ @j2cdir } > /dev/null 2>&1`
  end
  @logger.debug( "Image trackfile UUID: #{ image_mxf_uuid }" )
  
  # Make audio trackfile
  unless @source_audio.empty?
    @logger.info( 'Write audio trackfile ...' )
    `asdcp-test -L -E -p #{ fps } -a #{ audio_mxf_uuid } -c #{ audio_mxf } #{ @final_audio } > /dev/null 2>&1`
    @logger.debug( "Audio trackfile UUID: #{ audio_mxf_uuid }" )
  end

  # Write CompositionPlaylist
  @logger.info( 'Write CPL' )
  cpl_uuid = `kmuuidgen -n` # FIXME
  @logger.debug( "CPL UUID:       #{ cpl_uuid }" )
  cpl_file = File.join( @dcpdir, 'cpl_' + cpl_uuid + '_.xml' )
  cpl = CPL_SMPTE_429_7_2006.new( 
    cpl_uuid,
    image_mxf.to_a, # reels
    @source_audio.empty? ? nil : audio_mxf.to_a, # reels
    annotation = options.dcp_annotation,
    issue_date = DateTime.now.to_s,
    issuer = options.dcp_issuer,
    creator = 'cinemaslides cpl',
    content_title = options.dcp_title,
    content_kind = options.dcp_kind,
    content_version_id = cpl_uuid + '_' + issue_date,
    content_version_label = content_version_id,
    rating_list = nil
  )
  File.open( cpl_file, 'w' ) { |f| f.write( cpl.xml ) }

  # Write PackingList
  @logger.info( 'Write PKL ...' )
  # might be cumulative DCP, end up with 1 pkl to cover all
  obsolete_pkls = Dir.glob( File.join( @dcpdir, 'pkl_*_.xml' ) ) # FIXME check xml for packing list
  obsolete_pkls.each do |obsolete_pkl|
    @logger.debug( "Obsolete:   #{ File.basename( obsolete_pkl ) }" )
    File.delete( obsolete_pkl )
  end
  pkl_assets = Array.new
  pkl_assets << Dir.glob( File.join( @dcpdir, 'cpl_*_.xml' ) )
  pkl_assets << Dir.glob( File.join( @dcpdir, '*_.mxf' ) )
  pkl_uuid = `kmuuidgen -n`
  @logger.debug( "PKL UUID:       #{ pkl_uuid }" )
  pkl_file = File.join( @dcpdir, 'pkl_' + pkl_uuid + '_.xml' )
  pkl = PKL_SMPTE_429_8_2007.new(
    pkl_uuid,
    options.dcp_annotation, # FIXME
    issue_date = DateTime.now.to_s,
    options.dcp_issuer,
    creator = 'cinemaslides pkl',
    pkl_assets.flatten
  )
  File.open( pkl_file, 'w' ) { |f| f.write( pkl.xml ) }
  
  # Write Assetmap
  @logger.info( 'Write ASSETMAP' )
  am_assets = Array.new
  am_assets << pkl_assets
  am_assets << pkl_file
  am_uuid = `kmuuidgen -n`
  @logger.debug( "AM UUID:        #{ am_uuid }" )
  am_file = File.join( @dcpdir, 'ASSETMAP.xml' )
  am = AM_SMPTE_429_9_2007.new(
    am_uuid,
    issue_date = DateTime.now.to_s,
    options.dcp_issuer,
    creator = 'cinemaslides am',
    am_assets.flatten
  )
  File.open( am_file, 'w' ) { |f| f.write( am.xml ) }

  # readme and report
  readme_file = File.join( @dcpdir, options.dcp_annotation.gsub( ' ', '_' ) + '.readme' )
  File.open( readme_file, 'w' ) { |f| f.write( commandline + "\n" ) }
  final_report( sequence_frames, fps, options.transition_and_timing, options.keep )
  cleanup_workdir( options.keep )
  @logger.info( "DCP done" )

end # End Create DCP


TODO = <<TODO
FIXME fps and --wrap-stereoscopic not in total harmony yet
FIXME generic readme/report output
FIXME check write completion on slow media (with -o | --dcp-out)
FIXME cleanup dcpdir after montage summary exit (with -o ...)
FIXME sox, what's taking you so long? conform_audio()
FIXME projected length <- frames cast
FIXME estimate required/check available disk space
FIXME max number of commandline args? (32768 here)
FIXME See $ cinemaslides 01.jpg 02.jpg -x crossfade,1,0 (temporary @framecount fix in full_level())
FIXME verbosity level "info" -> jpeg 2000 encoder talk
FIXME crossfades border case: 0.0416666666666667 (1/24) crossfade time -> level shoots off the roof
FIXME gamma diff on resize: don't conform images with target dimensions
FIXME how to detect optimal -vo for mplayer?
FIXME crossfade,5,0 [5 images] -> 720 frames intended 725 frames created
FIXME cinemaslides multipage.pdf is somewhat borked because of assets creation (name), conforms to <digest>_<dimensions>_-<page_number>.jpg
      which won't fly at pickup time

FEATURE look at resize/don't resize thresholds in order to do the "right" thing for mixed source. bit shaky maybe.
FEATURE look at polynomial-constrained fades
FEATURE option to request linear/s-curved/... transitions for comparison (well, for showing off, basically, how nice the sigmoid function works for transitions)
FEATURE sparse assets via minimum mxfs and playlists
FEATURE 3D
FEATURE custom preview sizes
FEATURE black/mono pause between slides
FEATURE transition times and duration are global. make them file specific
FEATURE DCP naming conventions
FEATURE MPEG MXFI

CODE slideshow objects
CODE options catch all (missing arguments trace back deep)
CODE better way to check for and provide requirements alternatives ( mplayer|ffplay, openjpeg|kakadu etc. )

mplayer crash with some a710 jpgs. exif? portrait orientation + conform size exceed?
TODO

