#!/usr/bin/env ruby
CinemaSlidesVersion = "v0.2010.07.18"
Author = "Wolfgang Woehl".freeze
#
# Run "cinemaslides -h" to see options
#
# Export CINEMASLIDESDIR to point to the desired location for temporary files, asset depot etc.
#   (or use the default location HOME/cinemaslidesdir)
#
# Requires:
#   ruby, gem, bash
#   ImageMagick, MPlayer
#   OpenJPEG (http://code.google.com/p/openjpeg/downloads/list) or Kakadu (see the note on Kakadu's terms of use below)
#   asdcplib (http://www.cinecert.com/asdcplib/) and opencinematools (http://code.google.com/p/opencinematools/)
#   highline (gem install highline)
#   nokogiri (gem install nokogiri, requires ruby-dev, libxml2-dev)
#
###
#   Kakadu (http://www.kakadusoftware.com/index.php) is a proprietary JPEG 2000 implementation, written by Dr. Taubman
#   Kakadu Copyright is owned by NewSouth Innovations Proprietary Ltd, commercial arm of the University of New South Wales, Sydney, Australia
#   Its feature set and performance are quite impressive. It is significantly faster than OpenJPEG's implementation.
#   Kakadu is available for demonstration purposes (Windows, Mac, Linux).
#   Please see "Downloadable Executables Copyright and Disclaimer" at 
#   http://www.kakadusoftware.com/index.php?option=com_content&task=view&id=26&Itemid=22
#   and make sure you respect these terms of use. Thank you.
###
#
# Ruby geeks: If you value your sanity don't read beyond this line. I'm working on it ...

require 'fileutils'
require 'ftools' # File.copy. not needed (and not working) in ruby 1.9
require 'optparse'
require 'ostruct'
require 'digest/md5'
require 'pp'
begin
  require 'rubygems'
rescue LoadError
end
require 'nokogiri'
require 'highline/import'


# FIXME catch missing parameters, false options, typos etc.
class Optparser
  def self.parse(args)
    
    # defaults
    options = OpenStruct.new
    options.output_type = 'preview'
    options.size = '2k'
    options.size_choices = [ '2k', '4k' ]
    options.aspect = 'flat'
    options.aspect_choices = [ 'flat', 'scope', 'hd', Regexp.new('\d+(\.\d+)?x\d+(\.\d+)?') ] # custom aspect ratios: match '<numeric>x<numeric>'
    options.aspect_malformed = FALSE
    options.fps = 24.0
    options.fps_dcp_choices = [ 24.0, 48.0 ]
    options.fps_asdcp_choices = [ 23.976, 24.0, 25.0, 30.0, 48.0, 50.0, 60.0 ]
    options.encoder = 'openjpeg'
    options.encoder_choices = [ 'openjpeg', 'kakadu' ]
    options.output_format = 'jpg'
    options.black = 0
    options.title = 'Cinemaslides test'
    options.issuer = 'Wolfgang Woehl'
    options.annotation = 'Cinemaslides test'
    options.montage = FALSE
    options.keep = FALSE
    options.dont_check = FALSE
    options.dont_drop = FALSE
    options.verbosity = 'info'
    options.verbosity_choices = [ 'quiet', 'info', 'debug' ]
    options.transition_and_timing = Array.new
    options.transition_and_timing << 'fade'
    options.transition_and_timing << 0 # fade_in_time
    options.transition_and_timing << 5 # duration
    options.transition_and_timing << 0 # fade_out_time

    opts = OptionParser.new do |opts|
      opts.banner = <<BANNER
cinemaslides #{ CinemaSlidesVersion } #{ ENV[ 'CINEMASLIDESDIR' ].nil? ? "\nExport CINEMASLIDESDIR to point to desired work directory needed for temporary files, thumbnails, asset depot, dcps (Default: HOME/cinemaslidesdir)" : "\nCINEMASLIDESDIR is set (#{ ENV[ 'CINEMASLIDESDIR' ] })" }

Usage: #{ File.basename( $0 ) } [-t, --type <type>] [-k, --size <DCP resolution>] [-a, --aspect <aspect name or widthxheight>] [--fps <fps>] [-x --transition_and_timing <type,a,b[,c]>] [-j, --encoder <encoder>] [-f, --output_format <image suffix>] [-b, --black <seconds>] [-m, --montagepreview] [-v, --verbosity <level>] [--title <DCP title>] [--issuer <DCP issuer>] [--annotation <DCP annotation>] [--examples] [--keep] [ --dont-check ] [--dont-drop] image1 [image2 ...]

BANNER

      opts.on("-t", "--type type", String, "Use 'preview' (half size) or 'fullpreview' (full size) or 'dcp' (Default: preview)") do |p|
        options.output_type = p.downcase
      end
      opts.on("-k", "--size resolution", String, "Use '2k' or '4k' (Default: 2k)") do |p|
        if options.size_choices.include?( p.downcase )
          options.size = p.downcase
        else
          options.size = 'catch:' + p.downcase
        end
      end
      opts.on("-a", "--aspect ratio", String, "For standard aspect ratios use 'flat', 'scope' or 'hd' (Default: flat). You can also experiment with custom aspect ratios by saying '<width>x<height>'. The numbers given will be scaled to fit into the target container (Default size or specified with '--size').") do |p|
        if options.aspect_choices.include?( p.downcase )
          options.aspect = p.downcase
        elsif p.match( options.aspect_choices.last )
          options.aspect = 'Custom aspect ratio:' + p
        else
          options.aspect_malformed = TRUE
        end
      end
      opts.on("--fps fps", "Framerate (Default: 24)", Float) do |p| # 23.976
        options.fps = p.to_f
      end
      opts.on( "-x", "--transition_and_timing transition,seconds,seconds[,seconds]", Array, "Use this option to specify the transition type ('fade' or 'crossfade') and timing parameters. Defaults to '-x #{ options.transition_and_timing.join(',') }' (fade in #{ options.transition_and_timing[ 1 ] } seconds, full level #{ options.transition_and_timing[ 2 ] } seconds, fade out #{ options.transition_and_timing[ 3 ] } seconds). Separate parameters with commas (no spaces)" ) do |p|
        options.transition_and_timing = p
      end
      opts.on("-j", "--encoder codec", String, "Use 'openjpeg' or 'kakadu' for JPEG 2000 encoding (Default: openjpeg)") do |p|
        options.encoder = p.downcase
      end
      opts.on("-f", "--output_format", String, "Use 'jpg' or any other image related suffix (Default: jpg for previews, tiff for DCPs)") do |p|
        options.output_format = p
      end
      opts.on("-b", "--black seconds", Float, "Length of black leader and tail (Default: 0)") do |p|
        options.black = p
      end
      opts.on("--title title", "DCP title tag", String) do |p|
        options.title = p
      end
      opts.on("--issuer issuer", "DCP issuer tag", String) do |p|
        options.issuer = p
      end
      opts.on("--annotation annotation", "DCP annotation tag", String) do |p|
        options.annotation = p
      end
      opts.on("-m", "--montagepreview", "Display a montage of the images before processing") do
        options.montage = TRUE
      end
      opts.on( '--keep', 'Do not remove preview/temporary files' ) do
        options.keep = TRUE
      end
      opts.on( '--dont-check', 'Do not check files' ) do
        options.dont_check = TRUE
      end
      opts.on( '--dont-drop', 'Do not drop and ignore unreadable files or files ImageMagick cannot decode but nag and exit instead' ) do
        options.dont_drop = TRUE
      end
      opts.on("-v", "--verbosity level", String, "Use 'quiet', 'info' or 'debug' (Default: info)") do |p|
        if options.verbosity_choices.include?( p )
          options.verbosity = p
        else
          options.verbosity = "info"
        end
      end

      opts.on( '--examples', 'Some examples and explanations' ) do
        app = File.basename( $0 )
        examples = <<EXAMPLES
cinemaslides #{ CinemaSlidesVersion }

Specify options in any order. Order of images matters. 

  Preview slideshow (Half sized preview. Cut transition. Default duration: 5 seconds each):
$ #{ app } image1.jpg image2.tiff

  Preview slideshow (Full sized preview. Transition: crossfades for 1 second, 3 seconds at full level each):
$ #{ app } -t fullpreview -x crossfade,1,3 image1.tif image2.ppm

  Create slideshow DCP, use all image files in directory 'slides' (Resolution: 2K. 5 seconds black leader and tail):
$ #{ app } -t dcp --size 2k --black 5 slides/

  Create slideshow DCP (Preview thumbnails. Aspect ratio: scope):
$ #{ app } *.raw -m -a scope -t dcp --title 'Slideshow Test' --issuer 'Facility'

  Some kind of timing control:
$ #{ app } -x fade,0,3,0    title title title 1st_slide 2nd_slide disclaimer disclaimer
$ #{ app } -x crossfade,1,3 title title title 1st_slide 2nd_slide disclaimer disclaimer

  Slideshow of your truetype fonts:
$ #{ app } -x crossfade,2,2 `find /usr/share/fonts/truetype/ -name '*ttf' -type f`

  Custom aspect ratios (Work fine on a Solo G3, what about other servers?):
$ #{ app } --aspect 1.33x1 | --aspect 3072x2304 | --aspect 3x1 [...]
EXAMPLES
        puts examples
        exit
      end
      opts.on_tail( '-h', '--help', 'Display this screen' ) do
        puts opts
        exit
      end

    end
    opts.parse!(args)
    options
  end # parse
end # class
options = Optparser.parse(ARGV)


class Logger
  attr_accessor :prefix
  def initialize( prefix, verbosity )
    @verbosity = verbosity
    @critical = TRUE
    case @verbosity
    when "quiet"
      @info = FALSE
      @warn = FALSE
      @debug = FALSE
    when "info"
      @info = TRUE
      @warn = TRUE
      @debug = FALSE
    when "debug"
      @info = TRUE
      @warn = TRUE
      @debug = TRUE
    end
    @prefix = prefix
    @color = Hash.new
    # these work ok on a black background:
    @color[:info] = ''
    @color[:debug] = '32'
    @color[:warn] = '33'
    @color[:critical] = '1'
  end
  def info( text )
    to_console( @color[:info], text ) if @info == TRUE
  end
  def warn( text )
    to_console( @color[:warn], text ) if @warn == TRUE
  end
  def debug( text )
    to_console( @color[:debug], text ) if @debug == TRUE
  end
  def critical( text )
    to_console( @color[:critical], text ) if @critical == TRUE
  end
  def cr( text )
    carriage_return( @color[:info], text ) unless @verbosity == "quiet"
  end
  def carriage_return( color, text )
    printf "\033[#{ color }m#{ @prefix } #{ text }\033[0m#{ ' ' * 24 }\r"; STDOUT.flush
  end
  def to_console( color, text )
    printf "\033[#{ color }m#{ @prefix } #{ text }\033[0m#{ ' ' * 24 }\n"
  end
end
@logger = Logger.new( '*', options.verbosity ) # prefix messages with '*'


def check_requirements( requirements )
  available_tools = Array.new
  missing_tools = Array.new
  requirements.each do |tool|
    exitstatus = system "which #{ tool } > /dev/null 2>&1"
    case exitstatus
    when TRUE
      available_tools << tool
    when FALSE
      missing_tools << tool
    end
  end
  return available_tools, missing_tools
end


def hrs_min_sec( seconds )
  t = seconds
  hrs = ( ( t / 3600 ) ).to_i
  min = ( ( t / 60 ) % 60 ).to_i
  sec = t % 60
  return [
    hrs > 0 ? hrs.to_s + " hour#{ 's' * ( hrs > 1 ? 1 : 0 ) }" : nil ,
    min > 0 ? min.to_s + " minute#{ 's' * ( min > 1 ? 1 : 0 ) }" : nil ,
    sec > 0 ? sec.to_s + " second#{ 's' * ( sec > 1 ? 1 : 0 ) }" : '0 seconds' ,
    t > 60 ? "(#{ t } seconds)" : nil
  ].compact.join( ' ' )
end


def final_report( sequence_frames, fps, transition_and_timing, keep )
  sequence_duration = sequence_frames / fps
  @logger.debug( "#{ sequence_frames } frames intended by numbers (#{ hrs_min_sec( sequence_duration ) })" )
  @logger.debug( "#{ @framecount -1 } frames written" )
  @logger.info( "Cinema Slideshow is #{ hrs_min_sec( ( @framecount - 1 ) / fps ) } long (#{ @source.length } image#{ 's' * ( @source.length == 1 ? 0 : 1 )} | #{ transition_and_timing.join(',').gsub(' ', '') } | #{ @framecount - 1 } frames | #{ fps } fps)" )
  @logger.info( "Pick up preview files at #{ @workdir }/" ) if ( keep == TRUE and @output_type != 'dcp' )
  @logger.info( "Pick up temporary files at #{ @workdir }/" ) if ( keep == TRUE and @output_type == 'dcp' )
  @logger.info( "Pick up DCP at #{ @dcpdir }" ) if @output_type == 'dcp'
end


def cleanup_workdir( keep )
  case keep
  when FALSE
    case @output_type
    when 'preview', 'fullpreview'
      @logger.info( "Removing preview files (Say '--keep' to keep them)" )
      `rm -rf #{ @workdir }`
    when 'dcp'
      @logger.info( "Removing temporary files (Say '--keep' to keep them)" )
      `rm -rf #{ @conformdir }`
      `rm -rf #{ @j2cdir }`
    end
  end
end


def get_timestamp
  t = Time.now
  [t.year, '%02d' % t.month, '%02d' % t.day, '%02d' % t.hour, '%02d' % t.min, '%02d' % t.sec].join('_')
end
timestamp = get_timestamp


# fit custom aspect ratios into the target container dimensions (1k for preview, 2k/4k for fullpreview/dcp)
def scale_to_fit_container( width, height, container_width, container_height )
  factor = container_height / container_width > height / width ? container_width / width : container_height / height
  @logger.debug( "Scaling factor to fit custom aspect ratio #{ width } x #{ height } in #{ @size } container: #{ factor }" )
  width_scaled = width * factor
  height_scaled = height * factor
  return width_scaled.floor, height_scaled.floor
end


# target container dimensions are upscaled from 1k numbers
# (1k for preview, 2k and 4k for fullpreview and dcp)
# any custom aspect ratio is scaled to fit the target container
def width_x_height
  container_multiplier = @size.split( '' ).first.to_i
  container_width = 1024.0 * container_multiplier
  container_height = 540.0 * container_multiplier
  @logger.debug( "Container: #{ container_width } x #{ container_height } (1k multiplier: #{ container_multiplier })" )
  case @aspect
  when 'flat' # 1.85 : 1
    width, height = 999, 540
  when 'scope' # 2.39 : 1 (2.38694638694639)
    width, height = 1024, 429
  when 'hd' # 1.77 : 1 (1.77777777777778)
    width, height = 960, 540
  else # Custom aspect ratio
    custom_width, custom_height = @aspect.split( 'Custom aspect ratio:' ).last.split( 'x' )
    width, height = scale_to_fit_container( custom_width.to_f, custom_height.to_f, container_width, container_height )
    return [ width, height ].join( 'x' )
  end
  width *= container_multiplier
  height *= container_multiplier
  return [ width, height ].join( 'x' )
end


def make_black_frame( filename )
  case @output_type
  when 'preview', 'fullpreview'
    `convert -type TrueColor -size #{ @dimensions } xc:black -depth 8 #{ filename }`
  when 'dcp'
    `convert -type TrueColor -size #{ @dimensions } xc:black -depth 12 #{ filename }`
  end
end


def fade_in_hold_fade_out( image, fps, fade_in_time, duration, fade_out_time )
  if fade_in_time > 0
    fade_in( image, fps, fade_in_time )
  end
  if duration > 0
    full_level( image, fps, duration )
  end
  if fade_out_time > 0
    fade_out( image, fps, fade_out_time )
  end
end


def fade_in( image, fps, fade_in_time )
  @logger.info( ">>> Fade in #{ imagecount_info( image ) }" )
  level = -100
  step = 100 / ( fade_in_time * fps )
  level = _level( level, step )
  fade( image, fade_in_time, fps, level, step )
end


def fade_out( image, fps, fade_out_time )
  @logger.info( "<<< Fade out #{ imagecount_info( image ) }" )
  level = 0
  step = - ( 100 / ( fade_out_time * fps ) )
  level = _level( level, step )
  fade( image, fade_out_time, fps, level, step )
end


def fade( image, seconds, fps, level, step)
  ( 1..( seconds * fps ) ).each do
    filename = sequencefile
    @logger.cr( sprintf('%.2f', level) )
    asset, todo = check_for_asset( image, @output_format, fps, level )
    if todo == TRUE
      convert_apply_level( image, level, asset )
    end
    File.symlink( asset, filename )
    level = _level( level, step )
    @framecount += 1
  end
end


def crossfade( image1, image2, fps, seconds )
  @logger.info( "XXX Crossfade #{ imagecount_info( image1 ) }" )
  level = 100
  step = - ( 100 / ( seconds * fps ) )
  case @output_type
  when "dcp"
    compress = "-compress none"
    depth = "-depth 12"
  when "preview", "fullpreview"
    compress = ""
    depth = "-depth 8"
  end
  ( 1..( seconds * fps ) ).each do
    filename = sequencefile
    @logger.cr( sprintf( '%.2f', level ) )
    asset, todo = check_for_asset( [ image1, image2 ], @output_format, fps, level )
    if todo == TRUE
      composite( image1, level, image2, depth, compress, asset )
    end
    File.symlink( asset, filename )
    level = _level( level, step )
    @framecount += 1
  end
end


def full_level( image, fps, duration )
  @logger.info( "--- Full level #{ imagecount_info( image ) }" )
  level = 0
  file = sequencefile
  File.symlink( image, file )
  if ( 1 ..( duration * fps - 1 ) ).none? # only 1 image needed
    @framecount += 1 # temporary fix for FIXME @framecount stumble (Errno::EEXIST) on first fade out frame with 0 or 1 frame full level settings, like with $ cinemaslides 01.jpg 02.jpg -x crossfade,1,0
    @logger.debug( "Skip sequence links: Only 1 image needed here" )
  else
    @framecount += 1
    sequence_links_to_last_encoded_file( "full", duration, fps, file )
  end
end


def sequence_links_to_last_encoded_file( info, seconds, fps, file )
  ( 1..( seconds * fps - 1 ) ).each do # 1 file already written
    link = sequencefile
    # FIXME link available on all platforms?
    File.symlink( file, link )
    @framecount += 1
  end
end


def _level( level, step )
  level += step
  #level = ( ( level + step ) * 10 ** 3 ).round.to_f / 10 ** 3
end


def sign( value )
  return ( value.to_f / value.to_f.abs ).to_i
end


def sigmoid( value, initial, final, center, rate )
  if initial > final
    base = final
  else
    base = initial
  end
  return ( initial - final ).abs / ( 1.0 + Math.exp( rate * sign( final - initial ) * ( -( value - center ).to_f ) ) ) + base
end


def imagecount_info( image )
  "(#{ @imagecount } of #{ @source.length })"
end


def sequencefile
  File.join( @conformdir, "#{ '%06d' % @framecount }.#{ @output_format }" )
end


# asset match is based on a /conform's/ IM signature + dimensions + (level unless jpeg 2000 codestream requested) + (encoder + fps if jpeg 2000 codestream is requested) + suffix
def check_for_asset( filename_s, suffix, fps, level = nil )
  # 2 images from crossfade?
  if filename_s.size == 2
    id = `identify -format '%#' #{ filename_s[0] }`.chomp + '_' + `identify -format '%#' #{ filename_s[1] }`.chomp
    origin = [ File.basename( filename_s[ 0 ] ), File.basename( filename_s[ 1 ] ) ].join( ' X ' )
  else # not from crossfade
    id = `identify -format '%#' #{ filename_s }`.chomp
    origin = File.basename( filename_s )
  end
  assetname = File.join( @assetsdir, id + "_#{ @dimensions }#{ level.nil? ? '' : '_' + level.to_s }#{ @output_type == 'dcp' ? suffix == 'j2c' ? '_' + @encoder_id + '_' + fps.floor.to_s : '' : '_pre' }_.#{ suffix }" )
  if File.exists?( assetname )
    @logger.debug( "Skip: Asset exists (#{ origin } -> #{ File.basename( assetname ) })" )
    todo = FALSE
  else
    todo = TRUE
  end
  return assetname, todo
end


# all fade/crossfade ops are based on these assets
def conform( image, fps )
  @logger.info( "Conform #{ image }" )
  asset, todo = check_for_asset( image, @output_format, fps )
  if todo == TRUE
    convert_resize_extent_color_specs( image, asset )
  end
  return asset
end


# scale and fit any image to container size. apply color specs if dcp target
def convert_resize_extent_color_specs( image, filename )
  case @output_type
  when "preview", "fullpreview"
    `convert #{image} \
        -type TrueColor \
        -alpha Off \
        -gamma 0.454545454545455 \
        -resize #{ @dimensions } \
        -background black \
        -gravity center \
        -extent #{ @dimensions } \
        -depth 8 \
        -gamma 2.2 \
      #{ filename }`
  # kakadu needs uncompressed 12bpc files # FIXME dep compress on options.encoder
  when "dcp"
    `convert #{image} \
        -type TrueColor \
        -alpha Off \
        -gamma 0.454545454545455 \
        -resize #{ @dimensions } \
        -background black \
        -gravity center \
        -extent #{ @dimensions } \
        -recolor '#{ SRGB_TO_XYZ }' \
        -depth 12 \
        -gamma 2.6 \
        -compress none \
      #{ filename }`
  else # hello typo
    puts "Use '-t preview' (half size) or '-t fullpreview' (full size) or '-t dcp'.\nDefaults to 'preview'."
    exit
  end
end


# image is already conformed, just apply level here
def convert_apply_level( image, level, filename )
  case @output_type
  when "preview", "fullpreview"
    `convert #{image} \
        -type TrueColor \
        -gamma 0.454545454545455 \
        #{ fadetype( level ) } \
        -gamma 2.2 \
      #{ filename }`
when "dcp" # -compress none for kakadu
    `convert #{image} \
        -type TrueColor \
        -gamma 0.38461538461538458 \
        #{ fadetype( level ) } \
        -depth 12 \
        -gamma 2.6 \
        -compress none \
      #{ filename }`
  end
end


def fadetype( level )
  "-modulate #{ level + 100 },#{ level + 100 }"
  #"-brightness-contrast #{ level }x#{ level }" # not in ubuntu 10.04's im 6.5.7-8
end


def composite( image1, level, image2, depth, compress, output ) # -compress none for kakadu
  `composite -type TrueColor #{ image1 } -dissolve #{ level } #{ image2 } #{ depth } #{ compress } #{ output }`
end


def jpeg2000_dcp_rate_constraints( fps ) # returns bytes
  dcp_max_bps = 250000000
  max_per_image = ( dcp_max_bps / 8 / fps ).floor
  max_per_component = ( max_per_image / 1.25 ).floor
  return max_per_image, max_per_component
end


def sequence?( list )
  nil
end
###


requirements = [ 'convert', 'identify', 'montage', 'display', 'mplayer', 'image_to_j2k', 'kdu_compress', 'asdcp-test', 'kmuuidgen', 'mkcpl', 'mkpkl', 'mkmap' ]
available_tools, missing_tools = check_requirements( requirements )
if options.output_type == "dcp"
  if missing_tools.include?( "kdu_compress" )
    if missing_tools.include?( "image_to_j2k" ) # both openjpeg and kakadu not available
      @logger.warn( "No JPEG 2000 codec available (Needed for DCP creation). Check your installation." )
    elsif options.encoder == "kakadu" # openjpeg is available, kakadu is not
      options.encoder = "openjpeg"
      @logger.warn( "kakadu's kdu_compress is not available. Falling back to openjpeg" )
    end
  elsif missing_tools.include?( "image_to_j2k" ) # kakadu is available, openjpeg is not
    if options.encoder == "openjpeg"
      options.encoder = "kakadu"
      @logger.warn( "openjpeg's image_to_j2k is not available. Falling back to kakadu" )
    end
  end
end
# boy-oh-boy-oh-boy
if available_tools.size < requirements.size - 1 # all tools needed minus 1 codec alternative
  @logger.info( "Missing tools: #{ missing_tools.join(', ') }" ) unless missing_tools.empty?
  @logger.warn( "Check your tools" )
  exit
end
@logger.debug( "Available tools: #{ available_tools.sort.join(', ') }" ) unless available_tools.empty?
@logger.debug( "Missing tools: #{ missing_tools.join(', ') }" ) unless missing_tools.empty?
@logger.debug( "All necessary tools available" ) if missing_tools.empty? # FIXME


### Get options and initialize
case options.aspect_malformed
when TRUE
  @logger.info( "Malformed aspect ratio. Use #{ options.aspect_choices[ 0, options.aspect_choices.size - 1 ].join( ', ' ) } or <width>x<height>" )
  exit
when FALSE
  @aspect = options.aspect
  w, h = @aspect.split( 'Custom aspect ratio: ' ).last.match( options.aspect_choices.last ).to_s.split( 'x' )
  if ! h.nil?
    if w.to_f == 0 or h.to_f == 0
      @logger.info( "Zero in aspect ratio specs. Doesn't compute" )
      exit
    end
  end
end

m = options.size.match(/catch:(.*)/)
unless m.nil? 
  if m[1] == 'eep'
    @logger.info( "Optparser tango, did you mean to say --keep?" )
  else
    @logger.info( "Can't understand -k's parameter" )
  end
  exit
end

@output_type = options.output_type
case @output_type
when 'preview'
  @size = '1k'
else
  @size = options.size
end

@source = ARGV
unless options.dont_check == TRUE
  # glob dirs
  not_readable = Array.new
  @source_tmp = Array.new
  @source.each do |element|
    if File.exists?( element )
      ftype = File.ftype( element )
      if ftype == 'directory'
        more = Dir.glob( "#{ element }/*" ).sort # this breaks fast (subdirs)
        @source_tmp << more
      else
        @source_tmp << element
      end
    else
      not_readable << element
      @logger.debug( "Not readable: #{ element }" )
    end
  end
  @source = @source_tmp.flatten.compact.dup
  # check files
  no_decode_delegate = Array.new
  drops = FALSE
  @source_tmp = @source.clone
  @source.each do |file|
    identify = `identify -format '%m' #{ file } 2>/dev/null`.chomp
    if identify.empty?
      no_decode_delegate << file
      @source_tmp.delete( file )
      @logger.debug( "#{ file }: No decode delegate" )
    elsif identify == "SVG"
      xml = Nokogiri::XML( File.open( file ) )
      if xml.search( 'svg' ).empty?
        no_decode_delegate << file
        @source_tmp.delete( file )
        @logger.debug( "No <svg> node: #{ file }" )
      else # svg maybe useable
        @logger.debug( "#{ identify }: #{ file }" )
      end
    else # file is useable
      dimensions = `convert #{ file } -format '(%wx%h, 1:%[fx:w/h])' info:`.chomp
      @logger.debug( "#{ identify } #{ dimensions }: #{ file }" )
    end
  end
  if not_readable.size > 0
    drops = TRUE
    @logger.debug( "Not readable: #{ not_readable.join( ', ' ) }" )
  elsif not_readable.size == 0 and @source_tmp.size > 0
    @logger.debug( "All files readable" )
  end
  if no_decode_delegate.size > 0
    drops = TRUE
    @logger.debug( "ImageMagick has no code delegate for #{ no_decode_delegate.join( ', ' ) }" )
  end
  if @source_tmp.length == 0
    @logger.info( drops == FALSE ? "No image files specified" : "No useable image files")
    exit
  end
  if drops == TRUE
    if options.dont_drop == TRUE
      exit
    else
      @logger.debug( "Dropped some unuseable files. Say '--dont-drop' to exit in that case." )
    end
  end
  @source = @source_tmp.dup
end

# check dcp related options
if @output_type == "dcp"
  unless options.encoder_choices.include?( options.encoder )
    @logger.critical( "Not a usable encoder: '#{ options.encoder }'" )
    exit
  end
  # mark assets with encoder ids
  case options.encoder
  when 'openjpeg'
    @encoder_id = 'opj'
  when 'kakadu'
    @encoder_id = 'kdu'
  else
    @encoder_id = 'xxx' # FIXME
  end
  unless options.fps_dcp_choices.include?( options.fps )
    @logger.critical( "Not yet implemented: #{ options.fps } fps" )
    exit
  end
  @logger.debug( "DCP related options ok" )
end


# check options.transition_and_timing
options.transition_and_timing.first.downcase!
if options.transition_and_timing.first == "fade" and options.transition_and_timing.length == 4
  fade_in_time = options.transition_and_timing[1].to_f
  duration = options.transition_and_timing[2].to_f
  fade_out_time = options.transition_and_timing[3].to_f
elsif options.transition_and_timing.first == "crossfade" and options.transition_and_timing.length == 3
  crossfade_time = options.transition_and_timing[1].to_f
  duration = options.transition_and_timing[2].to_f
  if @source.length == 1
    @logger.warn( "Can't crossfade 1 image (#{ @source.first })" )
    @logger.info( "Either supply more than 1 image or change transition_and_timing to fade specs ('-x fade,a,b,c')" )
    exit
  end
else
  @logger.warn( "Malformed transition and timing specs" )
  @logger.info( "Use '-x fade,a,b,c' or '-x crossfade,a,b' (a = fade in time/crossfade time, b = full level time, c = fade out time)" )
  exit
end


fps = options.fps
@framecount = 1
@imagecount = 0
if @output_type == "dcp"
  @output_format = "tiff"
  original_suffix = @output_format
  SRGB_TO_XYZ = "0.4124564 0.3575761 0.1804375 0.2126729 0.7151522 0.0721750 0.0193339 0.1191920 0.9503041"
else
  @output_format = options.output_format
end


# set up work dirs
CINEMASLIDESDIR = ENV['CINEMASLIDESDIR']
if CINEMASLIDESDIR.nil?
  @cinemaslidesdir = File.join( ENV[ 'HOME' ], "cinemaslidesdir" )
  @logger.debug( "CINEMASLIDESDIR not set. Will use #{ @cinemaslidesdir }" )
else
  @logger.debug( "CINEMASLIDESDIR is set to #{ CINEMASLIDESDIR }" )
  @cinemaslidesdir = CINEMASLIDESDIR
end
@workdir = File.join( @cinemaslidesdir, "#{ File.basename( $0 ) }_#{ timestamp }_#{ @output_type }" )
@conformdir = File.join( @workdir, "conform" )
@thumbsdir = File.join( @cinemaslidesdir, "thumbs" )
@assetsdir = File.join( @cinemaslidesdir, "assets" )
###


@dimensions = width_x_height
x,y = @dimensions.split( 'x' ) # ugh
x = x.to_i / 6 # ugh ugh
y = y.to_i / 6 # ...
@thumbs_dimensions = [ x,y ].join( 'x' ) # oh dear


case @output_type
when "dcp"
  @logger.info( "Creating #{ @size.upcase } DCP (#{ @aspect } #{ @dimensions } @ #{ fps } fps). Encoder: #{ options.encoder }" )
  @logger.info( "Title:      #{ options.title } #{timestamp}" )
  @logger.info( "Annotation: #{ options.annotation } #{timestamp}" )
  @logger.info( "Issuer:     #{ options.issuer }" )
when "preview", "fullpreview"
  @logger.info( "Creating #{ @output_type } (#{ @aspect } #{ @dimensions } @ #{ fps } fps)" )
end


Dir.mkdir( @cinemaslidesdir ) unless File.exists?( @cinemaslidesdir )
Dir.mkdir( @assetsdir ) unless File.exists?( @assetsdir )


### Process all images

# thumbs and minimontage
if options.montage == TRUE
  Dir.mkdir( @thumbsdir ) unless File.exists?( @thumbsdir )
  @logger.info( "Create thumbnails" )
  thumbs = Array.new
  ( 0..( @source.length - 1 ) ).each do |i|
    thumbfile = File.join( @thumbsdir, Digest::MD5.hexdigest( File.read( @source[ i ] ) ) + "_#{ @thumbs_dimensions }_" + ".jpg" )
    if File.exists?( thumbfile )
      @logger.debug( "Skip: #{ File.basename( thumbfile ) } exists" )
      thumbs << thumbfile
      next
    else
      @logger.info( "Thumb for #{ @source[ i ] }" )
      `convert #{ @source[ i ] } \
         -type TrueColor \
         -resize #{ @thumbs_dimensions } \
         -background black \
         -gravity center \
         -extent #{ @thumbs_dimensions } \
         -depth 8 \
       #{ thumbfile }`
       thumbs << thumbfile
     end
  end
  thumbs = thumbs.join(' ')
  # cache montages, wacky-hacky using string of all thumbnail filenames (md5 hexdigest and some) to match
  thumbs_asset = File.join( @thumbsdir, Digest::MD5.hexdigest( thumbs ) + '_montage_.jpg' )
  if File.exists?( thumbs_asset )
    @logger.debug( "Skip: Montage exists (#{ File.basename( thumbs_asset ) })" )
  else
    tiles_x = Math.sqrt( @source.length ).ceil
    `montage #{ thumbs } \
       -mode Concatenate \
       -tile #{ tiles_x }x \
       -border 1 \
       -geometry '#{ x }x#{ y }+5+5>' \
       -bordercolor lightblue \
    #{ thumbs_asset }`
  end
  if ENV[ "DISPLAY" ].nil?
    @logger.warn( "DISPLAY not set. Skipping montage summary. #{ options.keep == TRUE ? nil : 'Say --keep to keep preview files.' }" )
  else
    @logger.warn( "Montage summary #{ @output_type }. Exit with ESC or 'q'" )
    `display #{ thumbs_asset }`
  end
  exit if agree( "Continue? " ) == FALSE
end # montage


### Create all frames
Dir.mkdir( @workdir )
Dir.mkdir( @conformdir )


# black leader
if options.black > 0
  @logger.info( "Black header: #{ options.black } seconds" )
  blackfile = sequencefile
  make_black_frame( blackfile )
  @framecount += 1
  sequence_links_to_last_encoded_file( "black", options.black, fps, blackfile )
end

### all images
keeper = nil # keep a conform for the next crossfade (2nd will be 1st then, don't conform again)
@source.each_index do |index|
  case options.transition_and_timing.first
  when "fade"
    @imagecount += 1
    image = conform( @source[ index  ], fps )
    fade_in_hold_fade_out( image, fps, fade_in_time, duration, fade_out_time )
  when "crossfade"
    @imagecount += 1
    case index
    when 0 # first image
      image1 = conform( @source[ index ], fps )
      image2 = conform( @source[ index + 1 ], fps )
      keeper = image2
      fade_in( image1, fps, crossfade_time )
      full_level( image1, fps, duration )
      crossfade( image1, image2, fps, crossfade_time )
    when @source.length - 1 # last image
      image = keeper
      full_level( image, fps, duration )
      fade_out( image, fps, crossfade_time )
    else
      image1 = keeper
      image2 = conform( @source[ index + 1 ], fps )
      keeper = image2
      full_level( image1, fps, duration )
      crossfade( image1, image2, fps, crossfade_time )
    end
  end
end

# black tail
if options.black > 0
  @logger.info( "Black tail: #{ options.black } seconds" )
  filename = sequencefile
  File.symlink( blackfile, filename )
  @framecount += 1
  sequence_links_to_last_encoded_file( "black", options.black, fps, blackfile )
end
###


### Create preview/fullpreview
case @output_type
when "preview", "fullpreview"
  sequence = File.join( "#{ @conformdir }", "*.#{ @output_format }" )
  if ENV[ "DISPLAY" ].nil?
    @logger.warn( "DISPLAY not set. Skipping preview. #{ options.keep == TRUE ? nil : 'Say --keep to keep preview files.' }" )
  else
    @logger.warn( "Loop #{ @output_type }. Exit with ESC or 'q'" )
    mplayer_vo = ""
    `mplayer -really-quiet mf://#{ sequence } -mf fps=#{ fps }:type=#{ @output_format } -loop 0 #{ mplayer_vo } > /dev/null 2>&1`
  end
  if options.transition_and_timing.first == "fade"
    sequence_frames = ( 2 * options.black + @source.length * ( fade_in_time + duration + fade_out_time ) ) * fps
  elsif options.transition_and_timing.first == "crossfade"
    sequence_frames = ( 2 * options.black + crossfade_time + @source.length * ( crossfade_time + duration ) ) * fps # implicit fade in/out first/last when crossfading
  end
  final_report( sequence_frames, fps, options.transition_and_timing, options.keep ) # FIXME
  cleanup_workdir( options.keep )
  @logger.info( "Preview done" )
  exit
###


### Create DCP (Encoding, asdcplib, oct)
when "dcp"
  @j2cdir = File.join( @workdir, "j2c" )
  @dcpdir = File.join( @workdir, "dcp" )
  tmp_slidesmxf = File.join( @dcpdir, 'tmp_j2c.mxf' )
  tmp_cpl = File.join( @dcpdir, 'tmp_cpl.xml' )
  tmp_pkl = File.join( @dcpdir, 'tmp_pkl.xml' )

  Dir.mkdir( @j2cdir )
  Dir.mkdir( @dcpdir )

  ## JPEG 2000 encoding
  @logger.info( "Encode to JPEG 2000" )
  filemask = File.join( @conformdir, "*.#{ @output_format }" )
  files = Dir.glob( filemask ).sort
  
  # openjpeg's profiles imply rate constraints, kakadu's don't
  max_bytes_per_image, max_bytes_per_component = jpeg2000_dcp_rate_constraints( fps )
  if @size == "2k"
    kakadu_cinema_profile = "CINEMA2K"
    openjpeg_cinema_profile = "cinema2K #{ fps }"
  elsif @size == "4k"
    kakadu_cinema_profile = "CINEMA4K"
    openjpeg_cinema_profile = "cinema4K"
  end
  counter = 0
  last_encoded_file = ""
  
  files.each do |file|
    counter += 1
    last_encoded_file = file + ".j2c"
    asset, todo = check_for_asset( file, "j2c", fps )
    if todo == TRUE
      @logger.cr( "#{ options.encoder }: #{ File.basename( file ) } (#{ counter } of #{ files.size })" )
      case options.encoder
      when 'openjpeg'
        `image_to_j2k -#{ openjpeg_cinema_profile } -i #{ file } -o #{ asset } > /dev/null 2>&1`
      when 'kakadu'
        `kdu_compress -i #{ file } -o #{ asset } Sprofile=#{ kakadu_cinema_profile } Creslengths=#{ max_bytes_per_image } Creslengths:C0=#{ max_bytes_per_image },#{ max_bytes_per_component } Creslengths:C1=#{ max_bytes_per_image },#{ max_bytes_per_component } Creslengths:C2=#{ max_bytes_per_image },#{ max_bytes_per_component }`
      end
    end
    File.link( asset, last_encoded_file )
  end

  `mv #{ File.join( @conformdir, '*.j2c' ) } #{ @j2cdir }`
  
  @logger.info( "Write image trackfile ..." )
  slidesmxf_uuid = `kmuuidgen -n`
  `asdcp-test -L -E -p #{ fps } -a #{ slidesmxf_uuid } -c #{ tmp_slidesmxf } #{ @j2cdir } > /dev/null 2>&1`
  @logger.debug( "trackfile uuid: #{ slidesmxf_uuid }" )
  slidesmxf = File.join( File.dirname( tmp_slidesmxf ), "j2c_" + slidesmxf_uuid + "_.mxf" )
  File.rename( tmp_slidesmxf, slidesmxf )

  @logger.info( "Write CPL" )
  `mkcpl --kind test --norating --title '#{ options.title } #{ timestamp }' --annotation '#{ options.annotation } #{ timestamp }' --issuer '#{ options.issuer }' #{ slidesmxf } > #{ tmp_cpl }`
  
  cpl_uuid = Nokogiri::XML( File.open( tmp_cpl ) ).xpath( "//xmlns:CompositionPlaylist/xmlns:Id" ).text.split( 'urn:uuid:' ).last
  @logger.debug( "cpl uuid      : #{ cpl_uuid }" )
  cpl = File.join( File.dirname( tmp_cpl ), "cpl_" + cpl_uuid + "_.xml" )
  File.rename( tmp_cpl, cpl )

  @logger.info( "Write PKL" )
  `mkpkl --issuer '#{ options.issuer }' --annotation '#{ options.annotation } #{ timestamp }' #{ slidesmxf } #{ cpl } > #{ tmp_pkl }`

  pkl_uuid = Nokogiri::XML( File.open( tmp_pkl ) ).xpath( "//xmlns:PackingList/xmlns:Id" ).text.split( 'urn:uuid:' ).last
  @logger.debug( "pkl uuid      : #{ pkl_uuid }" )
  pkl = File.join( File.dirname( tmp_pkl ), "pkl_" + pkl_uuid + "_.xml" )
  File.rename( tmp_pkl, pkl)
  @logger.info( "Write ASSETMAP and VOLINDEX" )
  `cd #{ @dcpdir }; mkmap --issuer '#{ options.issuer }' #{ File.basename( slidesmxf ) } #{ File.basename( cpl ) } #{ File.basename( pkl ) }`

  # FIXME report -> dry out
  # report
  if options.transition_and_timing.first == "fade"
    sequence_frames = ( 2 * options.black + @source.length * ( fade_in_time + duration + fade_out_time ) ) * fps
  elsif options.transition_and_timing.first == "crossfade"
    sequence_frames = ( 2 * options.black + crossfade_time + @source.length * ( crossfade_time + duration ) ) * fps # implicit fade in/out first/last when crossfading
  end
  final_report( sequence_frames, fps, options.transition_and_timing, options.keep )
  cleanup_workdir( options.keep )
  @logger.info( "DCP done" )

end # End Create DCP


TODO = <<TODO
FIXME max number of commandline args 32768
FIXME @framecount stumble (Errno::EEXIST) on first fade out frame with 0 or 1 frame full level settings, like with $ cinemaslides 01.jpg 02.jpg -x crossfade,1,0 (see temporary fix in full_level())
FIXME fades' symmetry broken
FIXME verbosity level info -> jpeg 2000 encoder talk
FIXME crossfades border case: 0.0416666666666667 (1/24) crossfade time -> level shoots off the roof
FIXME gamma diff on resize: don't conform images with target dimensions
FIXME how to detect optimal -vo for mplayer?
FIXME crossfade,5,0 [5 images] -> 720 frames intended 725 frames created
FIXME cinemaslides multipage.pdf is somewhat borked because of assets creation (name), conforms to <digest>_<dimensions>_-<page_number>.jpg
      which won't fly at pickup time
FIXME montage preview needs a border around thumbs (for white backgrounds of images etc.). Not working

FEATURE sparse assets via minimum mxfs and playlists
FEATURE audio
FEATURE 3D
FEATURE custom preview sizes
FEATURE black/mono pause between slides
FEATURE transition times and duration are global. make them file specific
FEATURE DCP naming conventions
FEATURE MPEG MXFI

CODE slideshow objects
CODE dry out black header/tail
CODE report method (also generalize transition types and timings)
CODE options catch all (missing arguments trace back deep)
CODE better way to check for and provide requirements alternatives ( mplayer|ffplay, openjpeg|kakadu etc. )

mplayer crash with some a710 jpgs. exif? portrait orientation + conform size exceed?
TODO

